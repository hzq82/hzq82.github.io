<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MY LIFE</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-03-29T16:00:00.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>harry</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redis</title>
    <link href="http://yoursite.com/2022/03/30/redis/"/>
    <id>http://yoursite.com/2022/03/30/redis/</id>
    <published>2022-03-29T16:00:00.000Z</published>
    <updated>2022-03-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis八股文系列"><a href="#Redis八股文系列" class="headerlink" title="Redis八股文系列"></a>Redis八股文系列</h1><h1 id="1-什么是-redis？"><a href="#1-什么是-redis？" class="headerlink" title="1.什么是 redis？"></a>1.什么是 redis？</h1><p>redis: redis 即 Remote Dictionary Server，用中文翻译过来可以理解为远程数据服务或远程字典服务。其是使用 C 语言的编写的 key-value 存储系统。</p><h2 id="1-1-redis-适合的场景"><a href="#1-1-redis-适合的场景" class="headerlink" title="1.1 redis 适合的场景"></a>1.1 redis 适合的场景</h2><ul><li><p>缓存：减轻 MySQL 的查询压力，提升系统性能；</p></li><li><p>排行榜：利用 Redis 的 SortSet（有序集合）实现；</p></li><li><p>计算器/限速器：利用 Redis 中原子性的自增操作，我们可以统计类似用户点赞数、用户访问数等。这类操作如果用 MySQL，频繁的读写会带来相当大的压力；限速器比较典型的使用场景是限制某个用户访问某个 API 的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力；</p></li><li><p>好友关系：利用集合的一些命令，比如求交集、并集、差集等。可以方便解决一些共同好友、共同爱好之类的功能；</p></li><li><p>消息队列：除了 Redis 自身的发布/订阅模式，我们也可以利用 List 来实现一个队列机制，比如：到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的 DB 压力，完全可以用 List 来完成异步解耦；</p></li><li><p>Session 共享：Session 是保存在服务器的文件中，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登录；采用 redis 保存 Session 后，无论用户落在哪台机器上都能够获取到对应的 Session 信息。</p><a id="more"></a></li></ul><h2 id="1-2-redis-不适合的场景"><a href="#1-2-redis-不适合的场景" class="headerlink" title="1.2 redis 不适合的场景"></a>1.2 redis 不适合的场景</h2><p>数据量太大、数据访问频率非常低的业务都不适合使用 Redis，数据太大会增加成本，访问频率太低，保存在内存中纯属浪费资源。</p><h2 id="1-3-redis-为什么这么快？"><a href="#1-3-redis-为什么这么快？" class="headerlink" title="1.3 redis 为什么这么快？"></a>1.3 redis 为什么这么快？</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/3wgqfEribn6cKZO2rr93H5nZz1VjzMBHpR9XtShJROPFAU8j0AwjcLj2rXZpxrTAPpGl7e4eMB5mcpQLYpg9wqg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h1 id="2-redis-有哪些数据类型？可以应用在什么场景？"><a href="#2-redis-有哪些数据类型？可以应用在什么场景？" class="headerlink" title="2. redis 有哪些数据类型？可以应用在什么场景？"></a>2. redis 有哪些数据类型？可以应用在什么场景？</h1><p>redis 总共有八种数据结构，五种基本数据类型和三种特殊数据类型。</p><ul><li><p>五种基本数据类型</p></li><li><ul><li>string :字符串类型，常被用来存储计数器，粉丝数等，简单的分布式锁也会用到该类型。</li><li>hashmap :key - value 形式的，value 是一个map。</li><li>list :基本的数据类型，列表。在 Redis 中可以把 list 用作栈、队列、阻塞队列。</li><li>set :集合，不能有重复元素，可以做点赞，收藏等。</li><li>zset :有序集合，不能有重复元素，有序集合中的每个元素都需要指定一个分数，根据分数对元素进行升序排序。可以做排行榜。</li></ul></li><li><p>三种特殊数据类型</p></li><li><ul><li>geospatial :Redis 在 3.2 推出 Geo 类型，该功能可以推算出地理位置信息，两地之间的距离。</li><li>hyperloglog :基数：数学上集合的元素个数，是不能重复的。这个数据结构常用于统计网站的 UV。</li><li>bitmap :bitmap 就是通过最小的单位 bit 来进行0或者1的设置，表示某个元素对应的值或者状态。一个 bit 的值，或者是0，或者是1；也就是说一个 bit 能存储的最多信息是2。bitmap 常用于统计用户信息比如活跃粉丝和不活跃粉丝、登录和未登录、是否打卡等。</li></ul></li></ul><h1 id="3-redis-是单线程还是多线程呢？"><a href="#3-redis-是单线程还是多线程呢？" class="headerlink" title="3. redis 是单线程还是多线程呢？"></a>3. redis 是单线程还是多线程呢？</h1><ul><li>Redis 在 4.0 的时候引入了多线程来做大缓存的清除处理工作，主要是体现在大数据的异步删除功能上，例如 unlink key、flushdb async、flushall async 等，先清除 key ，接着异步清除对应的 value。</li><li>在 Redis 6.0 之前的网络模型都是标准的单线程 reactor 模型。在 6.0 开始引入了一个非标准的多线程 reactor 模型，sub-reactor 此时会使用 socket 读取 client 请求，并处理命令的解析，然后具体写还是在主线程上执行。</li></ul><h2 id="3-1-redis-使用了多线程不会有线程安全的问题吗？为什么redis-6-0-之后改多线程呢？"><a href="#3-1-redis-使用了多线程不会有线程安全的问题吗？为什么redis-6-0-之后改多线程呢？" class="headerlink" title="3.1 redis 使用了多线程不会有线程安全的问题吗？为什么redis 6.0 之后改多线程呢？"></a>3.1 redis 使用了多线程不会有线程安全的问题吗？为什么redis 6.0 之后改多线程呢？</h2><p>不会，其实 redis 还是使用单线程模型来处理客户端的请求，只是使用多线程来处理数据的读写和协议解析，执行命令还是使用单线程，所以是不会有线程安全的问题。</p><p>之所以加入了多线程因为 redis 的性能瓶颈在于网络IO而非CPU，使用多线程能提升IO读写的效率，从而整体提高redis的性能。</p><h1 id="4-redis-的持久化机制有哪些？"><a href="#4-redis-的持久化机制有哪些？" class="headerlink" title="4. redis 的持久化机制有哪些？"></a>4. redis 的持久化机制有哪些？</h1><p>redis 有两种持久化的方式，AOF 和 RDB。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/3wgqfEribn6cKZO2rr93H5nZz1VjzMBHpiaUo1tDWFbTJEkbymm2ibIKT6JVsrEEwjqzIibtDibkRcldCw1oIoAfP0A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF:"></a>AOF:</h2><p>AOF（append only file） 持久化，redis 每次执行一个命令时，都会把这个「命令原本的语句记录到一个.aod的文件当中，然后通过fsync策略，将命令执行后的数据持久化到磁盘中」(不包括读命令)。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/3wgqfEribn6cKZO2rr93H5nZz1VjzMBHp7cF4FVl3icTb0Dr7ef7baAvYqljzby56by8kvFjqtzDcMiaPiavrzJofA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="AOF-的优点"><a href="#AOF-的优点" class="headerlink" title="AOF 的优点:"></a>AOF 的优点:</h3><ol><li>AOF可以「更好地保护数据不丢失」，一般AOF会以每隔1秒，通过后台的一个线程去执行一次fsync操作，如果redis进程挂掉，最多丢失1秒的数据。</li><li>AOF是将命令直接追加在文件末尾的,「写入性能非常高」。</li><li>AOF日志文件的命令通过非常可读的方式进行记录，这个非常「适合做灾难性的误删除紧急恢复」，如果某人不小心用 flushall 命令清空了所有数据，只要这个时候还没有执行 rewrite，那么就可以将日志文件中的 flushall 删除，进行恢复。</li></ol><h3 id="AOF-的缺点"><a href="#AOF-的缺点" class="headerlink" title="AOF 的缺点:"></a>AOF 的缺点:</h3><ol><li>对于同一份数据源来说,一般情况下AOF 文件比 RDB 数据快照要大。</li><li>由于 .aof 的每次命令都会写入，那么相对于 RDB 来说「需要消耗的性能也就更多」，当然也会有 aof 重写将 aof 文件优化。</li><li>「数据恢复比较慢」，不适合做冷备。</li></ol><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB:"></a>RDB:</h2><p>把某个时间点 redis 内存中的数据以二进制的形式存储的一个.rdb为后缀的文件当中，也就是「周期性的备份redis中的整个数据」，这是redis默认的持久化方式，也就是我们说的快照(snapshot)，是采用 fork 子进程的方式来写时同步的。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/3wgqfEribn6cKZO2rr93H5nZz1VjzMBHpVuXwvAtlVFEjeRRPpe3NkGtkVjAOPNvTZEtCznssNzKWXZLwrb4kAA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="RDB-的优点"><a href="#RDB-的优点" class="headerlink" title="RDB 的优点:"></a>RDB 的优点:</h3><ol><li>它是将某一时间点redis内的所有数据保存下来，所以当我们做「大型的数据恢复时，RDB的恢复速度会很快」。</li><li>由于RDB的FROK子进程这种机制，对于给客户端提供读写服务的影响会非常小。</li></ol><h3 id="RDB-的缺点"><a href="#RDB-的缺点" class="headerlink" title="RDB 的缺点:"></a>RDB 的缺点:</h3><p>举个例子假设我们定时5分钟备份一次，在10:00的时候 redis 备份了数据，但是如果在10:04的时候服务挂了，那么我们就会丢失在10:00到10:04的整个数据。</p><ol><li>「有可能会产生长时间的数据丢失」。</li><li>可能会有长时间停顿:我们前面讲了，fork 子进程这个过程是和 redis 的数据量有很大关系的，如果「数据量很大，那么很有可能会使redis暂停几秒」。</li></ol><h1 id="5-redis-的过期键的删除策略有哪些？"><a href="#5-redis-的过期键的删除策略有哪些？" class="headerlink" title="5. redis 的过期键的删除策略有哪些？"></a>5. redis 的过期键的删除策略有哪些？</h1><p><img src="https://mmbiz.qpic.cn/mmbiz_png/3wgqfEribn6cKZO2rr93H5nZz1VjzMBHpLYxnUR6meLvU5o6gqjIIZ4YTzfplibJ9OglicoQBRMlGbibGibOys8LBKQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><ul><li>定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的 CPU 资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</li><li>惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</li><li>定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。</li></ul><h1 id="6-redis-的内存淘汰策略"><a href="#6-redis-的内存淘汰策略" class="headerlink" title="6. redis 的内存淘汰策略"></a>6. redis 的内存淘汰策略</h1><p>实际上redis定义了「8种内存淘汰策略」用来处理redis内存满的情况：</p><ol><li>noeviction：默认策略，直接返回错误，不淘汰任何已经存在的redis键；</li><li>allkeys-lru：所有的键使用LRU（最近最少使用）算法进行淘汰；</li><li>volatile-lru：从设置了过期时间的key中使用LRU（最近最少使用）算法进行淘汰；</li><li>allkeys-random：随机删除 redis 键；</li><li>volatile-random：随机删除有过期时间的 redis 键；</li><li>volatile-ttl：删除快过期的redis键；</li><li>volatile-lfu：根据LFU算法从有过期时间的键删除；</li><li>allkeys-lfu：根据LFU算法从所有键删除；</li></ol><h1 id="7-redis-的热-key-问题怎么解决？"><a href="#7-redis-的热-key-问题怎么解决？" class="headerlink" title="7. redis 的热 key 问题怎么解决？"></a>7. redis 的热 key 问题怎么解决？</h1><p>热 key  就是说，在某一时刻，有非常多的请求访问某个 key，流量过大，导致该 redis 服务器宕机。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/3wgqfEribn6cKZO2rr93H5nZz1VjzMBHp5mff8RYPibo3vuQiao3WDkUenBWvz9RMzyuibGwxanoazx7xiboyUKPibeQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h2><ul><li>redis 集群扩容：增加分片副本，均衡读流量；</li><li>可以将结果缓存到本地内存中；</li><li>将热 key 分散到不同的服务器中；</li></ul><h1 id="9-缓存穿透、缓存击穿、缓存雪崩是什么？怎么解决呢？"><a href="#9-缓存穿透、缓存击穿、缓存雪崩是什么？怎么解决呢？" class="headerlink" title="9. 缓存穿透、缓存击穿、缓存雪崩是什么？怎么解决呢？"></a>9. 缓存穿透、缓存击穿、缓存雪崩是什么？怎么解决呢？</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指用户请求的数据在缓存中不存在并且在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍，然后返回空。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法:"></a>解决办法:</h3><ol><li>布隆过滤器</li></ol><p>将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。</p><ol><li>返回空对象</li></ol><p>如果一个查询返回的数据为空，我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p><p>缓存空对象带来的问题：</p><ul><li>空值做了缓存，那么缓存中便存了更多的键，需要更多的内存空间，比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。</li><li>缓存和存储的数据会有一段时间窗口的不一致，可能会对业务有一定影响。可以利用消息系统或者其他方式清除掉缓存层中的空对象。</li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿，是指一个 key 非常热点，在不停的扛着大并发，当这个 key 在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库导致宕机。</p><h3 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法:"></a>解决办法:</h3><ol><li>互斥锁</li></ol><p>缓存失效时，不是立即去加载db数据，而是先使用某些带成功返回的原子操作命令，如(Redis的setnx）去操作，成功的时候，再去加载db数据库数据和设置缓存。否则就去重试获取缓存。</p><ol><li>“永远不过期”</li></ol><p>(1) 从redis上看，确实没有设置过期时间，这就保证了，不会出现热点key过期问题，也就是“物理”不过期。</p><p>(2) 从功能上看，如果不过期，那不就成静态的了吗？所以我们把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建，也就是“逻辑”过期。</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩是指缓存中不同的数据大批量到过期时间，而查询数据量巨大，请求直接落到数据库上导致宕机。</p><h3 id="解决办法-2"><a href="#解决办法-2" class="headerlink" title="解决办法:"></a>解决办法:</h3><ol><li>均匀过期</li></ol><p>在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。</p><ol><li>双层缓存策略、二级缓存</li></ol><p>Cache1 为原始缓存，Cache2 为拷贝缓存，Cache1 失效时，可以访问 Cache2，Cache1 缓存失效时间设置为短期，Cache2 设置为长期。</p><ol><li>加互斥锁</li></ol><p>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待；</p><h1 id="10-redis-有哪些部署方式？"><a href="#10-redis-有哪些部署方式？" class="headerlink" title="10. redis 有哪些部署方式？"></a>10. redis 有哪些部署方式？</h1><ol><li>单机模式：这也是最基本的部署方式，只需要一台机器，负责读写，一般只用于开发人员自己测试。</li><li>哨兵模式：哨兵模式是一种特殊的模式，首先 redis 提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待 redis 服务器响应，从而监控运行的多个 redis 实例。它具备自动故障转移、集群监控、消息通知等功能。</li><li>cluster 集群模式：在 redis3.0 版本中支持了 cluster 集群部署的方式，这种集群部署的方式能自动将数据进行分片，每个 master 上放一部分数据，提供了内置的高可用服务，即使某个 master 挂了，服务还可以正常地提供。</li><li>主从复制：在主从复制这种集群部署模式中，我们会将数据库分为两类，第一种称为主数据库(master)，另一种称为从数据库(slave)。主数据库会负责我们整个系统中的读写操作，从数据库会负责我们整个数据库中的读操作。其中在职场开发中的真实情况是，我们会让主数据库只负责写操作，让从数据库只负责读操作，就是为了读写分离，减轻服务器的压力。</li></ol><h1 id="11-哨兵有哪些作用？"><a href="#11-哨兵有哪些作用？" class="headerlink" title="11. 哨兵有哪些作用？"></a>11. 哨兵有哪些作用？</h1><ol><li>监控整个主数据库和从数据库，观察它们是否正常运行；</li><li>当主数据库发生异常时，自动的将从数据库升级为主数据库，继续保证整个服务的稳定；</li></ol><h1 id="12-哨兵选举过程是怎么样的？"><a href="#12-哨兵选举过程是怎么样的？" class="headerlink" title="12. 哨兵选举过程是怎么样的？"></a>12. 哨兵选举过程是怎么样的？</h1><ol><li>第一个发现该 master 挂了的哨兵，向每个哨兵发送命令，让对方选举自己成为领头哨兵；</li><li>其他哨兵如果没有选举过他人，就会将这一票投给第一个发现该 master 挂了的哨兵；</li><li>第一个发现该 master 挂了的哨兵如果发现有超过一半哨兵投给自己，并且其数量也超过了设定的 quoram 参数，那么该哨兵就成了领头哨兵；</li><li>如果多个哨兵同时参与这个选举，那么就会重复该过程，直到选出一个领头哨兵；</li></ol><p>选出领头哨兵后，就开始了故障修复，会选出一个从数据库作为新的 master。</p><h1 id="13-什么是-Cluster-集群？"><a href="#13-什么是-Cluster-集群？" class="headerlink" title="13. 什么是 Cluster 集群？"></a>13. 什么是 Cluster 集群？</h1><p>edis 集群是一种分布式数据库方案，集群通过分片（sharding）来进行数据管理（「分治思想」的一种实践），并提供复制和故障转移功能。</p><p>将数据划分为 16384 的 slots，每个节点负责一部分槽位。槽位的信息存储于每个节点中。</p><p>它是去中心化的，如图所示，该集群由三个 Redis 节点组成，每个节点负责整个集群的一部分数据，每个节点负责的数据多少可能不一样。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/3wgqfEribn6cKZO2rr93H5nZz1VjzMBHpZGeVCqykiaPW4viaGPicTC5OR5eKPFdHnUftfw4pOJTNcmXnGibiaxHXzKQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h1 id="14-cluster-的故障恢复是怎么做的？"><a href="#14-cluster-的故障恢复是怎么做的？" class="headerlink" title="14. cluster 的故障恢复是怎么做的？"></a>14. cluster 的故障恢复是怎么做的？</h1><p>判断故障的逻辑其实与哨兵模式有点类似，在集群中，每个节点都会定期地向其他节点发送ping命令，通过有没有收到回复来判断其他节点是否已经下线。</p><p>如果长时间没有回复，那么发起ping命令的节点就会认为目标节点疑似下线，也可以和哨兵一样称作主观下线，当然也需要集群中一定数量的节点都认为该节点下线才可以，我们来说说具体过程：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/3wgqfEribn6cKZO2rr93H5nZz1VjzMBHpOsdZN91KHGc0Pl7gBhq3CKrxZZfSpkFQ2X6R5OZXFe2Xf10My1qlrA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><ol><li>当A节点发现目标节点疑似下线，就会向集群中的其他节点散播消息，其他节点就会向目标节点发送命令，判断目标节点是否下线</li><li>如果集群中半数以上的节点都认为目标节点下线，就会对目标节点标记为下线，从而告诉其他节点，让目标节点在整个集群中都下线</li></ol><h1 id="15-主从同步原理是怎样的？"><a href="#15-主从同步原理是怎样的？" class="headerlink" title="15. 主从同步原理是怎样的？"></a>15. 主从同步原理是怎样的？</h1><ol><li>当一个从数据库启动时，它会向主数据库发送一个SYNC命令，master收到后，在后台保存快照，也就是我们说的RDB持久化，当然保存快照是需要消耗时间的，并且redis是单线程的，在保存快照期间redis受到的命令会缓存起来</li><li>快照完成后会将缓存的命令以及快照一起打包发给slave节点，从而保证主从数据库的一致性。</li><li>从数据库接受到快照以及缓存的命令后会将这部分数据写入到硬盘上的临时文件当中，写入完成后会用这份文件去替换掉RDB快照文件，当然，这个操作是不会阻塞的，可以继续接收命令执行，具体原因其实就是fork了一个子进程，用子进程去完成了这些功能。</li></ol><p>因为不会阻塞，所以，这部分初始化完成后，当主数据库执行了改变数据的命令后，会异步地给slave，这也就是我们说的复制同步阶段，这个阶段会贯穿在整个中从同步的过程中，直到主从同步结束后，复制同步才会终止。</p><h1 id="16-无硬盘复制是什么？"><a href="#16-无硬盘复制是什么？" class="headerlink" title="16. 无硬盘复制是什么？"></a>16. 无硬盘复制是什么？</h1><p>我们刚刚说了主从之间是通过RDB快照来交互的，虽然看来逻辑很简单，但是还是会存在一些问题，但是会存在着一些问题。</p><ol><li>master禁用了RDB快照时，发生了主从同步(复制初始化)操作，也会生成RDB快照，但是之后如果master发成了重启，就会用RDB快照去恢复数据，这份数据可能已经很久了，中间就会丢失数据。</li><li>在这种一主多从的结构中，master每次和slave同步数据都要进行一次快照，从而在硬盘中生成RDB文件，会影响性能。</li></ol><p>为了解决这种问题，redis在后续的更新中也加入了无硬盘复制功能，也就是说直接通过网络发送给slave，避免了和硬盘交互，但是也是有io消耗。</p><h1 id="17-redis-如何实现分布式锁？"><a href="#17-redis-如何实现分布式锁？" class="headerlink" title="17. redis 如何实现分布式锁？"></a>17. redis 如何实现分布式锁？</h1><p>redis 为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对 redis 的连接并不存在竞争关系 redis 中可以使用 SETNX 命令实现分布式锁。</p><p>当且仅当 key 不存在，将 key 的值设为 value。若给定的 key 已经存在，则 SETNX 不做任何动作 SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p><p>返回值：设置成功，返回 1 。设置失败，返回 0 。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/3wgqfEribn6cKZO2rr93H5nZz1VjzMBHpmfyvMmXymlAKhBGKeibx2mKB5VUvicANPfxCJ2Ka73RC9dQum3nRy3PA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>使用 SETNX 完成同步锁的流程及事项如下：</p><ol><li>使用 SETNX 命令获取锁，若返回0（key已存在，锁已存在）则获取失败，反之获取成功；</li><li>为了防止获取锁后程序出现异常，导致其他线程/进程调用SETNX命令总是返回0而进入死锁状态，需要为该 key 设置一个“合理”的过期时间；</li><li>释放锁，使用DEL命令将锁数据删除；</li></ol><h1 id="18-redis的跳跃表"><a href="#18-redis的跳跃表" class="headerlink" title="18. redis的跳跃表"></a>18. redis的跳跃表</h1><p><img src="https://mmbiz.qpic.cn/mmbiz_png/3wgqfEribn6cKZO2rr93H5nZz1VjzMBHpcWJRm4Do1a1drsicOtOKPAQpjbFwgpVGIC63LgUPMyib6sRuuUlvVQJw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><ul><li>跳跃表是有序集合zset的底层实现之一。</li><li>跳跃表支持平均O（logN），最坏 O（N）复杂度的节点查找，还可以通过顺序性操作批量处理节点。</li><li>跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息（如表头节点、表尾节点、长度），而zskiplistNode则用于表示跳跃表节点。</li><li>跳跃表就是在链表的基础上，增加多级索引提升查找效率。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Redis八股文系列&quot;&gt;&lt;a href=&quot;#Redis八股文系列&quot; class=&quot;headerlink&quot; title=&quot;Redis八股文系列&quot;&gt;&lt;/a&gt;Redis八股文系列&lt;/h1&gt;&lt;h1 id=&quot;1-什么是-redis？&quot;&gt;&lt;a href=&quot;#1-什么是-redis？&quot; class=&quot;headerlink&quot; title=&quot;1.什么是 redis？&quot;&gt;&lt;/a&gt;1.什么是 redis？&lt;/h1&gt;&lt;p&gt;redis: redis 即 Remote Dictionary Server，用中文翻译过来可以理解为远程数据服务或远程字典服务。其是使用 C 语言的编写的 key-value 存储系统。&lt;/p&gt;
&lt;h2 id=&quot;1-1-redis-适合的场景&quot;&gt;&lt;a href=&quot;#1-1-redis-适合的场景&quot; class=&quot;headerlink&quot; title=&quot;1.1 redis 适合的场景&quot;&gt;&lt;/a&gt;1.1 redis 适合的场景&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;缓存：减轻 MySQL 的查询压力，提升系统性能；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;排行榜：利用 Redis 的 SortSet（有序集合）实现；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;计算器/限速器：利用 Redis 中原子性的自增操作，我们可以统计类似用户点赞数、用户访问数等。这类操作如果用 MySQL，频繁的读写会带来相当大的压力；限速器比较典型的使用场景是限制某个用户访问某个 API 的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;好友关系：利用集合的一些命令，比如求交集、并集、差集等。可以方便解决一些共同好友、共同爱好之类的功能；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;消息队列：除了 Redis 自身的发布/订阅模式，我们也可以利用 List 来实现一个队列机制，比如：到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的 DB 压力，完全可以用 List 来完成异步解耦；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Session 共享：Session 是保存在服务器的文件中，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登录；采用 redis 保存 Session 后，无论用户落在哪台机器上都能够获取到对应的 Session 信息。&lt;/p&gt;</summary>
    
    
    
    <category term="ops" scheme="http://yoursite.com/categories/ops/"/>
    
    
    <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>mysql</title>
    <link href="http://yoursite.com/2022/03/23/mysql/"/>
    <id>http://yoursite.com/2022/03/23/mysql/</id>
    <published>2022-03-22T16:00:00.000Z</published>
    <updated>2022-03-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span> <span class="string">flush privileges;</span></span><br><span class="line"><span class="meta">mysql&gt;GRANT</span> <span class="string">ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;a&#x27;; #赋权，使其可以远程登录</span></span><br></pre></td></tr></table></figure><h3 id="8-0安装"><a href="#8-0安装" class="headerlink" title="8.0安装"></a>8.0安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#https:&#x2F;&#x2F;www.modb.pro&#x2F;db&#x2F;332219</span><br><span class="line">wget https:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;mysql80-community-release-el7-5.noarch.rpm</span><br><span class="line">yum install -y mysql80-community-release-el7-5.noarch.rpm</span><br><span class="line">yum install -y mysql-community-server</span><br><span class="line"></span><br><span class="line">#修改临时密码</span><br><span class="line">grep &#39;temporary password&#39; &#x2F;var&#x2F;log&#x2F;mysqld.log</span><br><span class="line">mysql -uroot -p</span><br><span class="line">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;1234Qwer@&#39;;</span><br><span class="line"></span><br><span class="line">#配置允许远程登录</span><br><span class="line">USE mysql;</span><br><span class="line">UPDATE user SET host &#x3D; &#39;%&#39; WHERE user &#x3D; &#39;root&#39;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"></span><br><span class="line">#查看版本</span><br><span class="line">[root@template opt]# mysqladmin --version</span><br><span class="line">mysqladmin  Ver 8.0.28 for Linux on x86_64 (MySQL Community Server - GPL)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1NF  原子性</span><br><span class="line">2NF  解决字段部分依赖主键的问题，也就是复合主键问题，实际开发中基本不用复合主键。</span><br><span class="line">3NF  一张表中的所有字段都应该直接依赖主键，不应该有传递依赖</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h4&gt;&lt;figure class=&quot;highlight properties&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter</summary>
      
    
    
    
    <category term="ops" scheme="http://yoursite.com/categories/ops/"/>
    
    
    <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>ops笔记</title>
    <link href="http://yoursite.com/2022/03/21/ops%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2022/03/21/ops%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-20T16:00:00.000Z</published>
    <updated>2022-03-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料<a href="https://blog.51cto.com/13490688/2061070">https://blog.51cto.com/13490688/2061070</a></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo 无法登陆报错curl 28 OpenSSL SSL_read: Connection was reset, errno 10054</span><br><span class="line">git config --global http.sslVerify &quot;false&quot;</span><br><span class="line">查看swap</span><br><span class="line">for i in &#96;cd &#x2F;proc;ls |grep &quot;^[0-9]&quot;|awk &#39; $0 &gt;100&#39;&#96; ;do awk &#39;&#x2F;Swap:&#x2F;&#123;a&#x3D;a+$2&#125;END&#123;print &#39;&quot;$i&quot;&#39;,a&#x2F;1024&quot;M&quot;&#125;&#39; &#x2F;proc&#x2F;$i&#x2F;smaps ;done 2&gt;&amp;1 |sort -k2nr |head</span><br></pre></td></tr></table></figure><h4 id="postfix-维护"><a href="#postfix-维护" class="headerlink" title="postfix 维护"></a>postfix 维护</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">systemctl</span> <span class="string">start postfix</span></span><br><span class="line"><span class="attr">vi</span> <span class="string">/etc/postfix/main.cf #发信功能配置文件</span></span><br><span class="line"><span class="attr">service</span> <span class="string">dovecot start</span></span><br><span class="line"><span class="attr">vi</span> <span class="string">/etc/dovecot/dovecot.conf #收信功能配置文件</span></span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="1-39-取随机数"><a href="#1-39-取随机数" class="headerlink" title="1-39 取随机数"></a>1-39 取随机数</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">expr</span> <span class="string">$[RANDOM%39+1] 或 expr $[$RANDOM%39] + 1</span></span><br><span class="line"><span class="meta">使用expr</span> <span class="string">进行运算</span></span><br><span class="line"><span class="attr">使用Linux系统里面自带的随机变量RANDOM</span></span><br><span class="line"><span class="attr">利用%对39取余得到0-38的随机数</span></span><br><span class="line"><span class="attr">再进行+1处理得到1-39的随机数</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;参考资料&lt;a href=&quot;https://blog.51cto.com/13490688/2061070&quot;&gt;https://blog.51cto.com/13490688/2061070&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo 无法登陆报错curl 28 OpenSSL SSL_read: Connection was reset, errno 10054&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --global http.sslVerify &amp;quot;false&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;查看swap&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for i in &amp;#96;cd &amp;#x2F;proc;ls |grep &amp;quot;^[0-9]&amp;quot;|awk &amp;#39; $0 &amp;gt;100&amp;#39;&amp;#96; ;do awk &amp;#39;&amp;#x2F;Swap:&amp;#x2F;&amp;#123;a&amp;#x3D;a+$2&amp;#125;END&amp;#123;print &amp;#39;&amp;quot;$i&amp;quot;&amp;#39;,a&amp;#x2F;1024&amp;quot;M&amp;quot;&amp;#125;&amp;#39; &amp;#x2F;proc&amp;#x2F;$i&amp;#x2F;smaps ;done 2&amp;gt;&amp;amp;1 |sort -k2nr |head&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;


&lt;h4 id=&quot;postfix-维护&quot;&gt;&lt;a href=&quot;#postfix-维护&quot; class=&quot;headerlink&quot; title=&quot;postfix 维护&quot;&gt;&lt;/a&gt;postfix 维护&lt;/h4&gt;&lt;figure class=&quot;highlight properties&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;systemctl&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;start postfix&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;vi&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;/etc/postfix/main.cf #发信功能配置文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;service&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;dovecot start&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;vi&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;/etc/dovecot/dovecot.conf #收信功能配置文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="ops" scheme="http://yoursite.com/categories/ops/"/>
    
    
    <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>go</title>
    <link href="http://yoursite.com/2021/01/07/go%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2021/01/07/go%E7%AC%94%E8%AE%B0/</id>
    <published>2021-01-07T06:59:50.000Z</published>
    <updated>2021-01-07T06:59:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#Golang 的fmt 包实现了格式化I&#x2F;O函数，类似于C的 printf 和 scanf</span><br><span class="line"># 定义示例类型和变量</span><br><span class="line">type Human struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var people &#x3D; Human&#123;Name:&quot;zhangsan&quot;&#125;</span><br></pre></td></tr></table></figure><h3 id="普通占位符"><a href="#普通占位符" class="headerlink" title="普通占位符"></a>普通占位符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">占位符     说明                           举例                   输出</span><br><span class="line">%v      相应值的默认格式。            Printf(&quot;%v&quot;, people)   &#123;zhangsan&#125;，</span><br><span class="line">%+v     打印结构体时，会添加字段名     Printf(&quot;%+v&quot;, people)  &#123;Name:zhangsan&#125;</span><br><span class="line">%#v     相应值的Go语法表示            Printf(&quot;#v&quot;, people)   main.Human&#123;Name:&quot;zhangsan&quot;&#125;</span><br><span class="line">%T      相应值的类型的Go语法表示       Printf(&quot;%T&quot;, people)   main.Human</span><br><span class="line">%%      字面上的百分号，并非值的占位符  Printf(&quot;%%&quot;)            %</span><br></pre></td></tr></table></figure><h3 id="布尔占位符号"><a href="#布尔占位符号" class="headerlink" title="布尔占位符号"></a>布尔占位符号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">占位符       说明                举例                     输出</span><br><span class="line">%t          true 或 false。     Printf(&quot;%t&quot;, true)       true</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="整数占位符"><a href="#整数占位符" class="headerlink" title="整数占位符"></a>整数占位符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">占位符     说明                                  举例                       输出</span><br><span class="line">%b      二进制表示                             Printf(&quot;%b&quot;, 5)             101</span><br><span class="line">%c      相应Unicode码点所表示的字符              Printf(&quot;%c&quot;, 0x4E2D)        中</span><br><span class="line">%d      十进制表示                             Printf(&quot;%d&quot;, 0x12)          18</span><br><span class="line">%o      八进制表示                             Printf(&quot;%d&quot;, 10)            12</span><br><span class="line">%q      单引号围绕的字符字面值，由Go语法安全地转义 Printf(&quot;%q&quot;, 0x4E2D)        &#39;中&#39;</span><br><span class="line">%x      十六进制表示，字母形式为小写 a-f         Printf(&quot;%x&quot;, 13)             d</span><br><span class="line">%X      十六进制表示，字母形式为大写 A-F         Printf(&quot;%x&quot;, 13)             D</span><br><span class="line">%U      Unicode格式：U+1234，等同于 &quot;U+%04X&quot;   Printf(&quot;%U&quot;, 0x4E2D)         U+4E2D</span><br></pre></td></tr></table></figure><h3 id="浮点数和复数的组成部分"><a href="#浮点数和复数的组成部分" class="headerlink" title="浮点数和复数的组成部分"></a>浮点数和复数的组成部分</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">占位符     说明                              举例            输出</span><br><span class="line">%b      无小数部分的，指数为二的幂的科学计数法，</span><br><span class="line">        与 strconv.FormatFloat 的 &#39;b&#39; 转换格式一致。例如 -123456p-78</span><br><span class="line">%e      科学计数法，例如 -1234.456e+78        Printf(&quot;%e&quot;, 10.2)     1.020000e+01</span><br><span class="line">%E      科学计数法，例如 -1234.456E+78        Printf(&quot;%e&quot;, 10.2)     1.020000E+01</span><br><span class="line">%f      有小数点而无指数，例如 123.456        Printf(&quot;%f&quot;, 10.2)     10.200000</span><br><span class="line">%g      根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(&quot;%g&quot;, 10.20)   10.2</span><br><span class="line">%G      根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(&quot;%G&quot;, 10.20+2i) (10.2+2i)</span><br></pre></td></tr></table></figure><h3 id="字符串与字节切片"><a href="#字符串与字节切片" class="headerlink" title="字符串与字节切片"></a>字符串与字节切片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">占位符     说明                              举例                           输出</span><br><span class="line">%s      输出字符串表示（string类型或[]byte)   Printf(&quot;%s&quot;, []byte(&quot;Go语言&quot;))  Go语言</span><br><span class="line">%q      双引号围绕的字符串，由Go语法安全地转义  Printf(&quot;%q&quot;, &quot;Go语言&quot;)         &quot;Go语言&quot;</span><br><span class="line">%x      十六进制，小写字母，每字节两个字符      Printf(&quot;%x&quot;, &quot;golang&quot;)         676f6c616e67</span><br><span class="line">%X      十六进制，大写字母，每字节两个字符      Printf(&quot;%X&quot;, &quot;golang&quot;)         676F6C616E67</span><br></pre></td></tr></table></figure><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">占位符         说明                      举例                             输出</span><br><span class="line">%p      十六进制表示，前缀 0x          Printf(&quot;%p&quot;, &amp;people)             0x4f57f0</span><br></pre></td></tr></table></figure><h3 id="其他标记"><a href="#其他标记" class="headerlink" title="其他标记"></a>其他标记</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">占位符      说明                             举例          输出</span><br><span class="line">+      总打印数值的正负号；对于%q（%+q）保证只输出ASCII编码的字符。 </span><br><span class="line">                                           Printf(&quot;%+q&quot;, &quot;中文&quot;)  &quot;\u4e2d\u6587&quot;</span><br><span class="line">-      在右侧而非左侧填充空格（左对齐该区域）</span><br><span class="line">#      备用格式：为八进制添加前导 0（%#o）      Printf(&quot;%#U&quot;, &#39;中&#39;)      U+4E2D</span><br><span class="line">       为十六进制添加前导 0x（%#x）或 0X（%#X），为 %p（%#p）去掉前导 0x；</span><br><span class="line">       如果可能的话，%q（%#q）会打印原始 （即反引号围绕的）字符串；</span><br><span class="line">       如果是可打印字符，%U（%#U）会写出该字符的</span><br><span class="line">       Unicode 编码形式（如字符 x 会被打印成 U+0078 &#39;x&#39;）。</span><br><span class="line">&#39; &#39;    (空格)为数值中省略的正负号留出空白（% d）；</span><br><span class="line">       以十六进制（% x, % X）打印字符串或切片时，在字节之间用空格隔开</span><br><span class="line">0      填充前导的0而非空格；对于数字，这会将填充移到正负号之后</span><br></pre></td></tr></table></figure><h3 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">golang没有 &#39;%u&#39; 点位符，若整数为无符号类型，默认就会被打印成无符号的。</span><br><span class="line"></span><br><span class="line">宽度与精度的控制格式以Unicode码点为单位。宽度为该数值占用区域的最小宽度；精度为小数点之后的位数。</span><br><span class="line">操作数的类型为int时，宽度与精度都可用字符 &#39;*&#39; 表示。</span><br><span class="line"></span><br><span class="line">对于 %g&#x2F;%G 而言，精度为所有数字的总数，例如：123.45，%.4g 会打印123.5，（而 %6.2f 会打印123.45）。</span><br><span class="line"></span><br><span class="line">%e 和 %f 的默认精度为6</span><br><span class="line"></span><br><span class="line">对大多数的数值类型而言，宽度为输出的最小字符数，如果必要的话会为已格式化的形式填充空格。</span><br><span class="line"></span><br><span class="line">而以字符串类型，精度为输出的最大字符数，如果必要的话会直接截断。</span><br></pre></td></tr></table></figure><h3 id="判断-类型"><a href="#判断-类型" class="headerlink" title="判断 类型"></a>判断 类型</h3><p>类似于 JavaScript 中 typeof 和 Java 中 instanceof</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var&#96; &#96;a &#96;&#96;interface&#96;&#96;&#123;&#125;&#96;&#96;newA, ok :&#x3D; a.(string)&#96;&#96;&#x2F;&#x2F; 如果 ok 是 true，则说明 变量 a 是字符串类型，而 newA 就是 string 类型的变量，a 的实际值&#96;&#96;&#x2F;&#x2F;</span><br></pre></td></tr></table></figure><h3 id="判断-key-是否在-map-中"><a href="#判断-key-是否在-map-中" class="headerlink" title="判断 key 是否在 map 中"></a>判断 key 是否在 map 中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var&#96; &#96;nameList &#x3D; &#96;&#96;map&#96;&#96;[string]string&#123;&#96;&#96;&quot;姓名&quot;&#96;&#96;: &#96;&#96;&quot;李四&quot;&#96;&#96;, &#96;&#96;&quot;性别&quot;&#96;&#96;: &#96;&#96;&quot;男&quot;&#96;&#96;&#125;&#96;&#96;name, ok :&#x3D; nameList[&#96;&#96;&quot;姓名&quot;&#96;&#96;] &#96;&#96;&#x2F;&#x2F; 假如 key 存在，则 ok &#x3D; true，否则，ok &#x3D; false&#96;&#96;if&#96; &#96;ok &#123;&#96;&#96; &#96;&#96;fmt.Println(name)&#96;&#96;&#125;</span><br></pre></td></tr></table></figure><h3 id="判断-channel-是否-已关闭-且-没有数据"><a href="#判断-channel-是否-已关闭-且-没有数据" class="headerlink" title="判断 channel 是否 已关闭 且 没有数据"></a>判断 channel 是否 已关闭 且 没有数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for&#96; &#96;&#123;&#96;&#96;  &#96;&#96;x, ok :&#x3D; &lt;-chantest&#96;&#96;  &#96;&#96;if&#96; &#96;!ok &#123;&#96;&#96;    &#96;&#96;break&#96; &#96;&#x2F;&#x2F; 通道 已关闭 且 没有数据，则跳出循环&#96;&#96;  &#96;&#96;&#125;&#96;&#96;&#125;</span><br></pre></td></tr></table></figure><h3 id="和-amp-的区别"><a href="#和-amp-的区别" class="headerlink" title="*和&amp;的区别 :"></a>*和&amp;的区别 :</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. &amp; 是取地址符号 , 即取得某个变量的地址 , 如 ; &amp;a</span><br><span class="line">2. *是指针运算符 , 可以表示一个变量是指针类型 , 也可以表示一个指针变量所指向的存储单元 , 也就是这个地址所存储的值 .</span><br></pre></td></tr></table></figure><h3 id="是赋值，-是声明变量并赋值。"><a href="#是赋值，-是声明变量并赋值。" class="headerlink" title="= 是赋值， := 是声明变量并赋值。"></a>= 是赋值， := 是声明变量并赋值。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; &#x3D; 使用必须使用先var声明例如：</span><br><span class="line">var a</span><br><span class="line">a&#x3D;100</span><br><span class="line">&#x2F;&#x2F;或</span><br><span class="line">var b &#x3D; 100</span><br><span class="line">&#x2F;&#x2F;或</span><br><span class="line">var c int &#x3D; 100</span><br><span class="line">&#x2F;&#x2F; :&#x3D; 是声明并赋值，并且系统自动推断类型，不需要var关键字</span><br><span class="line">d :&#x3D; 100</span><br></pre></td></tr></table></figure><h3 id="NEW"><a href="#NEW" class="headerlink" title="NEW"></a>NEW</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new是用来分配内存的内建函数，区别于其他语言中new会初始化内存，golang中的new只会将内存置零。</span><br><span class="line">也就是说，new(T)会为类型为T的新项分配已置零的内存空间，并返回它的地址。也就是一个类型为*T的值。在GO中就是它返回一个指针，该指针指向新分配的，类型为T的零值。</span><br><span class="line">零值属性带来的好处就是当我们用new声明某种类型时就已经分配好内存了，无需进一步处理即可正常工作。</span><br><span class="line">make 和new 都是用来初始化内存、</span><br><span class="line">new多用来为基本数据类型（bool,string,int...）初始化内存，返回的是指针</span><br><span class="line">make 用来初始化slice，map，channel，返回的是对应类型</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SyncedBuffer <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock    sync.Mutex</span><br><span class="line">    buffer  bytes.Buffer</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SyncedBuffer 类型的值在声明时就分配好内存就绪了，后续代码中p,v无需进一步处理即可正确工作</span></span><br><span class="line">p := <span class="built_in">new</span>(SyncedBuffer)  <span class="comment">// type  *SyncedBuffer</span></span><br><span class="line"><span class="keyword">var</span> v SyncedBuffer      <span class="comment">// type SyncedBuffer</span></span><br></pre></td></tr></table></figure><h3 id="gin"><a href="#gin" class="headerlink" title="gin"></a>gin</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go mod init gin</span><br><span class="line">go mod edit -require github.com&#x2F;gin-gonic&#x2F;gin@latest</span><br><span class="line">go mod tidy</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out.SetText(&quot;Hello&quot;)</span><br></pre></td></tr></table></figure><h3 id="中文支持"><a href="#中文支持" class="headerlink" title="中文支持"></a>中文支持</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在github上找到一个go的库:go-findfont</span><br><span class="line">通过引入该库,可以实现查找系统字库的方法，此时引入对应的字库即可,不过目前该库只能找到TTF的字库,TTC的找不到,我使用的操作系统是win10，里面微软雅黑的字体格式是TTC的，因此我使用了楷体和黑体，具体的需要在操作系统的字体设置中查看。</span><br><span class="line">2020&#x2F;8&#x2F;09 更正：给作者提了ISSUE,现已支持ttc格式的字库了</span><br><span class="line">找到对应的字体，用代码设置环境变量即可</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「cplasfwst」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;cplasfwst&#x2F;article&#x2F;details&#x2F;109550090</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func init() &#123;</span><br><span class="line">fontPaths :&#x3D; findfont.List()</span><br><span class="line">for _, path :&#x3D; range fontPaths &#123;</span><br><span class="line">fmt.Println(path)</span><br><span class="line">&#x2F;&#x2F;楷体:simkai.ttf</span><br><span class="line">&#x2F;&#x2F;黑体:simhei.ttf</span><br><span class="line">if strings.Contains(path, &quot;simkai.ttf&quot;) &#123;</span><br><span class="line">os.Setenv(&quot;FYNE_FONT&quot;, path)</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;不要忘记在main方法的最后使用</span><br><span class="line">os.Unsetenv(&quot;FYNE_FONT&quot;)</span><br><span class="line">&#x2F;&#x2F;用来取消环境变量</span><br></pre></td></tr></table></figure><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">go build -ldflags&#x3D;&quot;-s -w -H windowsgui&quot;  -o hd.exe main.go</span><br><span class="line">go build -ldflags&#x3D;&quot;-s -w -H windowsgui&quot; -o hd.exe .</span><br><span class="line"></span><br><span class="line">upx.exe -9 winGuiHd.exe #压缩  </span><br><span class="line"></span><br><span class="line">#https:&#x2F;&#x2F;www.freesion.com&#x2F;article&#x2F;1123135476&#x2F;</span><br><span class="line">#https:&#x2F;&#x2F;blog.51cto.com&#x2F;9406836&#x2F;2490936?source&#x3D;dra   #添加图标</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;tour.go-zh.org&#x2F;  </span><br><span class="line">https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;18511154519&#x2F;zvideos?page&#x3D;1  #茹姐</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;hzq82&#x2F;Golang-100-Days</span><br><span class="line">https:&#x2F;&#x2F;blog.51cto.com&#x2F;lifeng&#x2F;2538861   #占位符</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;占位符&quot;&gt;&lt;a href=&quot;#占位符&quot; class=&quot;headerlink&quot; title=&quot;占位符&quot;&gt;&lt;/a&gt;占位符&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#Golang 的fmt 包实现了格式化I&amp;#x2F;O函数，类似于C的 printf 和 scanf&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 定义示例类型和变量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;type Human struct &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Name string&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var people &amp;#x3D; Human&amp;#123;Name:&amp;quot;zhangsan&amp;quot;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;普通占位符&quot;&gt;&lt;a href=&quot;#普通占位符&quot; class=&quot;headerlink&quot; title=&quot;普通占位符&quot;&gt;&lt;/a&gt;普通占位符&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;占位符     说明                           举例                   输出&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;%v      相应值的默认格式。            Printf(&amp;quot;%v&amp;quot;, people)   &amp;#123;zhangsan&amp;#125;，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;%+v     打印结构体时，会添加字段名     Printf(&amp;quot;%+v&amp;quot;, people)  &amp;#123;Name:zhangsan&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;%#v     相应值的Go语法表示            Printf(&amp;quot;#v&amp;quot;, people)   main.Human&amp;#123;Name:&amp;quot;zhangsan&amp;quot;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;%T      相应值的类型的Go语法表示       Printf(&amp;quot;%T&amp;quot;, people)   main.Human&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;%%      字面上的百分号，并非值的占位符  Printf(&amp;quot;%%&amp;quot;)            %&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;布尔占位符号&quot;&gt;&lt;a href=&quot;#布尔占位符号&quot; class=&quot;headerlink&quot; title=&quot;布尔占位符号&quot;&gt;&lt;/a&gt;布尔占位符号&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;占位符       说明                举例                     输出&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;%t          true 或 false。     Printf(&amp;quot;%t&amp;quot;, true)       true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="ops" scheme="http://yoursite.com/categories/ops/"/>
    
    
    <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>osi模型</title>
    <link href="http://yoursite.com/2020/12/10/osi%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/12/10/osi%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-12-10T02:30:00.000Z</published>
    <updated>2020-12-10T02:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="七层模型"><a href="#七层模型" class="headerlink" title="七层模型"></a>七层模型</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">应用层</span></span><br><span class="line"><span class="attr">网络服务与最终用户的一个接口。</span></span><br><span class="line"><span class="meta">协议有：HTTP</span> <span class="string">FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP</span></span><br><span class="line"><span class="attr">表示层</span></span><br><span class="line"><span class="attr">数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层）</span></span><br><span class="line"><span class="meta">格式有，JPEG、ASCll、EBCDIC、加密格式等</span> <span class="string">[2] </span></span><br><span class="line"><span class="attr">会话层</span></span><br><span class="line"><span class="attr">建立、管理、终止会话。（在五层模型里面已经合并到了应用层）</span></span><br><span class="line"><span class="attr">对应主机进程，指本地主机与远程主机正在进行的会话</span></span><br><span class="line"><span class="attr">传输层</span></span><br><span class="line"><span class="attr">定义传输数据的协议端口号，以及流控和差错校验。</span></span><br><span class="line"><span class="meta">协议有：TCP</span> <span class="string">UDP，数据包一旦离开网卡即进入网络传输层</span></span><br><span class="line"><span class="attr">网络层</span></span><br><span class="line"><span class="attr">进行逻辑地址寻址，实现不同网络之间的路径选择。</span></span><br><span class="line"><span class="meta">协议有：ICMP</span> <span class="string">IGMP IP（IPV4 IPV6）</span></span><br><span class="line"><span class="attr">数据链路层</span></span><br><span class="line"><span class="meta">建立逻辑连接、进行硬件地址寻址、差错校验</span> <span class="string">[3]  等功能。（由底层网络定义协议）</span></span><br><span class="line"><span class="attr">将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。</span></span><br><span class="line"><span class="attr">物理层</span></span><br><span class="line"><span class="attr">建立、维护、断开物理连接。（由底层网络定义协议）</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/hzq82/img/master/img/osi.gif"></p><p><img src="https://raw.githubusercontent.com/hzq82/img/master/img/osi.jpg"></p><p>四层负载均衡，是主要作用于TCP协议报文之上，基于IP+端口来判断需要重定向的报文，并修改报文中目标IP地址以进行重定向的负载均衡方式。</p><h4 id="ipvs"><a href="#ipvs" class="headerlink" title="ipvs"></a>ipvs</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Kubernetes的ClusterIP和NodePort都是通过ipvs service实现的，Pod当作ipvs service的server，通过NAT MQSQ实现转发。</span><br><span class="line"></span><br><span class="line">简单来说kube-proxy主要在所有的Node节点做如下三件事:</span><br><span class="line"></span><br><span class="line">    如果没有dummy类型虚拟网卡，则创建一个，默认名称为kube-ipvs0;把Kubernetes ClusterIP地址添加到kube-ipvs0，同时添加到ipset中。创建ipvs service，ipvs service地址为ClusterIP以及Cluster Port，ipvs server为所有的Endpoint地址，即Pod IP及端口。</span><br><span class="line"></span><br><span class="line">使用ipvs作为kube-proxy后端，不仅提高了转发性能，结合ipset还使iptables规则变得更“干净”清楚，从此再也不怕iptables。</span><br><span class="line"></span><br><span class="line">ipvs是专门设计用来做内核态四层负载均衡的，由于使用了hash表的数据结构，因此相比iptables来说性能会更好。基于ipvs实现Service转发，Kubernetes几乎能够具备无限的水平扩展能力。随着Kubernetes的部署规模越来越大，应用越来越广泛，ipvs必然会取代iptables成为Kubernetes Service的默认实现后端。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;七层模型&quot;&gt;&lt;a href=&quot;#七层模型&quot; class=&quot;headerlink&quot; title=&quot;七层模型&quot;&gt;&lt;/a&gt;七层模型&lt;/h4&gt;&lt;figure class=&quot;highlight properties&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter</summary>
      
    
    
    
    <category term="ops" scheme="http://yoursite.com/categories/ops/"/>
    
    
    <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>centos7扩展根目录,升级内核</title>
    <link href="http://yoursite.com/2020/12/08/centos7%E6%89%A9%E5%B1%95%E6%A0%B9%E7%9B%AE%E5%BD%95-%E5%8D%87%E7%BA%A7%E5%86%85%E6%A0%B8/"/>
    <id>http://yoursite.com/2020/12/08/centos7%E6%89%A9%E5%B1%95%E6%A0%B9%E7%9B%AE%E5%BD%95-%E5%8D%87%E7%BA%A7%E5%86%85%E6%A0%B8/</id>
    <published>2020-12-08T06:59:50.000Z</published>
    <updated>2020-12-08T06:59:50.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">df</span> <span class="string">-h</span></span><br><span class="line"><span class="attr">umount</span> <span class="string">/home</span></span><br><span class="line"><span class="attr">vim</span> <span class="string">/etc/fstab ####(注释掉/home,避免开机自检)</span></span><br><span class="line"><span class="attr">lvremove</span> <span class="string">/dev/mapper/centos-home #接着会出现确认的内容，输入“y”，回车</span></span><br><span class="line"><span class="attr">vgdisplay</span> <span class="string">#ps: 查看 Free  PE / Size这项</span></span><br><span class="line"><span class="attr">Free</span>  <span class="string">PE / Size       37151 / 145.12 GiB</span></span><br><span class="line"><span class="attr">lvextend</span> <span class="string">-L +145G /dev/mapper/centos-root #扩展/root所在的lv</span></span><br><span class="line"><span class="attr">xfs_growfs</span> <span class="string">/dev/mapper/centos-root #扩展/root空间</span></span><br><span class="line"><span class="attr">df</span> <span class="string">-h #成功</span></span><br></pre></td></tr></table></figure><h4 id="升级内核"><a href="#升级内核" class="headerlink" title="升级内核"></a>升级内核</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">## 载入公钥</span><br><span class="line">$ rpm --import https:&#x2F;&#x2F;www.elrepo.org&#x2F;RPM-GPG-KEY-elrepo.org</span><br><span class="line"></span><br><span class="line">## 安装 ELRepo 最新版本</span><br><span class="line">$ yum install -y https:&#x2F;&#x2F;www.elrepo.org&#x2F;elrepo-release-7.el7.elrepo.noarch.rpm</span><br><span class="line"></span><br><span class="line">## 列出可以使用的 kernel 包版本</span><br><span class="line">$ yum list available --disablerepo&#x3D;* --enablerepo&#x3D;elrepo-kernel</span><br><span class="line"></span><br><span class="line">## 安装指定的 kernel 版本：</span><br><span class="line">$ yum install -y kernel-lt-4.4.218-1.el7.elrepo --enablerepo&#x3D;elrepo-kernel</span><br><span class="line"></span><br><span class="line">## 查看系统可用内核</span><br><span class="line">$ cat &#x2F;boot&#x2F;grub2&#x2F;grub.cfg | grep menuentry</span><br><span class="line"></span><br><span class="line">menuentry &#39;CentOS Linux (3.10.0-1062.el7.x86_64) 7 (Core)&#39; --class centos （略）</span><br><span class="line">menuentry &#39;CentOS Linux (4.4.218-1.el7.elrepo.x86_64) 7 (Core)&#39; --class centos ...（略）</span><br><span class="line"></span><br><span class="line">## 设置开机从新内核启动</span><br><span class="line">$ grub2-set-default &quot;CentOS Linux (4.4.218-1.el7.elrepo.x86_64) 7 (Core)&quot;</span><br><span class="line"></span><br><span class="line">## 查看内核启动项</span><br><span class="line">$ grub2-editenv list</span><br><span class="line">saved_entry&#x3D;CentOS Linux (4.4.218-1.el7.elrepo.x86_64) 7 (Core)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;命令&quot;&gt;&lt;a href=&quot;#命令&quot; class=&quot;headerlink&quot; title=&quot;命令&quot;&gt;&lt;/a&gt;命令&lt;/h4&gt;&lt;figure class=&quot;highlight properties&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;</summary>
      
    
    
    
    <category term="ops" scheme="http://yoursite.com/categories/ops/"/>
    
    
    <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>k8s集群应用部署</title>
    <link href="http://yoursite.com/2020/11/11/k8s%E9%9B%86%E7%BE%A4%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2/"/>
    <id>http://yoursite.com/2020/11/11/k8s%E9%9B%86%E7%BE%A4%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2/</id>
    <published>2020-11-11T02:00:00.000Z</published>
    <updated>2020-11-11T02:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="集群常用命令"><a href="#集群常用命令" class="headerlink" title="集群常用命令"></a>集群常用命令</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kubectl</span> <span class="string">create deployment java-demo --image=harry82/tomcat:v1 --dry-run=client -o yaml &gt; java-demo.yaml</span></span><br><span class="line"><span class="attr">kubectl</span> <span class="string">expose deployment java-demo --port=80 --target-port=8080 --type=NodePort --dry-run=client -o yaml &gt;svc.yaml</span></span><br><span class="line"><span class="attr">kubectl</span> <span class="string">get pod -o wide</span></span><br><span class="line"><span class="attr">kubectl</span> <span class="string">desribe pod nginx-f89759699-gjgbn</span></span><br><span class="line"><span class="attr">kubectl</span> <span class="string">get ep #查看svc关联pod</span></span><br><span class="line"></span><br><span class="line"><span class="attr">kubectl</span> <span class="string">create deployment nginx --image=nginx</span></span><br><span class="line"></span><br><span class="line"><span class="attr">kubectl</span> <span class="string">get cm</span></span><br><span class="line"><span class="attr">kubectl</span> <span class="string">describe cm petclinic-config</span></span><br><span class="line"></span><br><span class="line"><span class="attr">kubectl</span> <span class="string">logs [podName] #注意如果pod里容器大于1,则不能使用这种方法访问</span></span><br><span class="line"><span class="attr">kubectl</span> <span class="string">logs -f &lt;pod-name&gt; # 实时查看日志</span></span><br><span class="line"><span class="attr">kubectl</span> <span class="string">log myapp-pod -c test #查看容器日志（如果pod里大于1个容器，那么要加-c [容器名称]）</span></span><br><span class="line"><span class="attr">kubectl</span> <span class="string">delete pod fluentd-bq8px -n kube-logging --grace-period=0 --force  #强制删除无法删除的pod</span></span><br><span class="line"><span class="attr">kubectl</span> <span class="string">logs --tail 200 kube-apiserver-master  -n kube-system</span></span><br></pre></td></tr></table></figure><h3 id="K8s-部署java应用"><a href="#K8s-部署java应用" class="headerlink" title="K8s 部署java应用"></a>K8s 部署java应用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;192.168.102.160:30001</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="deployment-yaml"><a href="#deployment-yaml" class="headerlink" title="deployment yaml"></a>deployment yaml</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion</span>: <span class="string">apps/v1  # 指定api版本，此值必须在kubectl api-versions中  </span></span><br><span class="line"><span class="attr">kind</span>: <span class="string">Deployment  # 指定创建资源的角色/类型   </span></span><br><span class="line"><span class="attr">metadata</span>:  <span class="string"># 资源的元数据/属性 </span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">demo  # 资源的名字，在同一个namespace中必须唯一</span></span><br><span class="line">  <span class="attr">namespace</span>: <span class="string">default # 部署在哪个namespace中</span></span><br><span class="line">  <span class="attr">labels</span>:  <span class="string"># 设定资源的标签</span></span><br><span class="line">    <span class="attr">app</span>: <span class="string">demo</span></span><br><span class="line">    <span class="attr">version</span>: <span class="string">stable</span></span><br><span class="line"><span class="attr">spec</span>: <span class="string"># 资源规范字段</span></span><br><span class="line">  <span class="attr">replicas</span>: <span class="string">1 # 声明副本数目</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit</span>: <span class="string">3 # 保留历史版本</span></span><br><span class="line">  <span class="attr">selector</span>: <span class="string"># 选择器</span></span><br><span class="line">    <span class="attr">matchLabels</span>: <span class="string"># 匹配标签</span></span><br><span class="line">      <span class="attr">app</span>: <span class="string">demo</span></span><br><span class="line">      <span class="attr">version</span>: <span class="string">stable</span></span><br><span class="line">  <span class="attr">strategy</span>: <span class="string"># 策略</span></span><br><span class="line">    <span class="attr">rollingUpdate</span>: <span class="string"># 滚动更新</span></span><br><span class="line">      <span class="attr">maxSurge</span>: <span class="string">30% # 最大额外可以存在的副本数，可以为百分比，也可以为整数</span></span><br><span class="line">      <span class="attr">maxUnavailable</span>: <span class="string">30% # 示在更新过程中能够进入不可用状态的 Pod 的最大值，可以为百分比，也可以为整数</span></span><br><span class="line">    <span class="attr">type</span>: <span class="string">RollingUpdate # 滚动更新策略</span></span><br><span class="line">  <span class="attr">template</span>: <span class="string"># 模版</span></span><br><span class="line">    <span class="attr">metadata</span>: <span class="string"># 资源的元数据/属性 </span></span><br><span class="line">      <span class="attr">annotations</span>: <span class="string"># 自定义注解列表</span></span><br><span class="line">        <span class="meta">sidecar.istio.io/inject</span>: <span class="string">&quot;false&quot; # 自定义注解名字</span></span><br><span class="line">      <span class="attr">labels</span>: <span class="string"># 设定资源的标签</span></span><br><span class="line">        <span class="attr">app</span>: <span class="string">demo</span></span><br><span class="line">        <span class="attr">version</span>: <span class="string">stable</span></span><br><span class="line">    <span class="attr">spec</span>: <span class="string"># 资源规范字段</span></span><br><span class="line">      <span class="attr">containers</span>:<span class="string"></span></span><br><span class="line">      <span class="meta">-</span> <span class="string">name: demo # 容器的名字   </span></span><br><span class="line">        <span class="attr">image</span>: <span class="string">demo:v1 # 容器使用的镜像地址   </span></span><br><span class="line">        <span class="attr">imagePullPolicy</span>: <span class="string">IfNotPresent # 每次Pod启动拉取镜像策略，三个选择 Always、Never、IfNotPresent</span></span><br><span class="line"><span class="comment">                                      # Always，每次都检查；Never，每次都不检查（不管本地是否有）；IfNotPresent，如果本地有就不检查，如果没有就拉取 </span></span><br><span class="line">        <span class="attr">resources</span>: <span class="string"># 资源管理</span></span><br><span class="line">          <span class="attr">limits</span>: <span class="string"># 最大使用</span></span><br><span class="line">            <span class="attr">cpu</span>: <span class="string">300m # CPU，1核心 = 1000m</span></span><br><span class="line">            <span class="attr">memory</span>: <span class="string">500Mi # 内存，1G = 1000Mi</span></span><br><span class="line">          <span class="attr">requests</span>:  <span class="string"># 容器运行时，最低资源需求，也就是说最少需要多少资源容器才能正常运行</span></span><br><span class="line">            <span class="attr">cpu</span>: <span class="string">100m</span></span><br><span class="line">            <span class="attr">memory</span>: <span class="string">100Mi</span></span><br><span class="line">        <span class="attr">livenessProbe</span>: <span class="string"># pod 内部健康检查的设置</span></span><br><span class="line">          <span class="attr">httpGet</span>: <span class="string"># 通过httpget检查健康，返回200-399之间，则认为容器正常</span></span><br><span class="line">            <span class="attr">path</span>: <span class="string">/healthCheck # URI地址</span></span><br><span class="line">            <span class="attr">port</span>: <span class="string">8080 # 端口</span></span><br><span class="line">            <span class="attr">scheme</span>: <span class="string">HTTP # 协议</span></span><br><span class="line"><span class="comment">            # host: 127.0.0.1 # 主机地址</span></span><br><span class="line">          <span class="attr">initialDelaySeconds</span>: <span class="string">30 # 表明第一次检测在容器启动后多长时间后开始</span></span><br><span class="line">          <span class="attr">timeoutSeconds</span>: <span class="string">5 # 检测的超时时间</span></span><br><span class="line">          <span class="attr">periodSeconds</span>: <span class="string">30 # 检查间隔时间</span></span><br><span class="line">          <span class="attr">successThreshold</span>: <span class="string">1 # 成功门槛</span></span><br><span class="line">          <span class="attr">failureThreshold</span>: <span class="string">5 # 失败门槛，连接失败5次，pod杀掉，重启一个新的pod</span></span><br><span class="line">        <span class="attr">readinessProbe</span>: <span class="string"># Pod 准备服务健康检查设置</span></span><br><span class="line">          <span class="attr">httpGet</span>:<span class="string"></span></span><br><span class="line">            <span class="attr">path</span>: <span class="string">/healthCheck</span></span><br><span class="line">            <span class="attr">port</span>: <span class="string">8080</span></span><br><span class="line">            <span class="attr">scheme</span>: <span class="string">HTTP</span></span><br><span class="line">          <span class="attr">initialDelaySeconds</span>: <span class="string">30</span></span><br><span class="line">          <span class="attr">timeoutSeconds</span>: <span class="string">5</span></span><br><span class="line">          <span class="attr">periodSeconds</span>: <span class="string">10</span></span><br><span class="line">          <span class="attr">successThreshold</span>: <span class="string">1</span></span><br><span class="line">          <span class="attr">failureThreshold</span>: <span class="string">5</span></span><br><span class="line"><span class="comment">        #也可以用这种方法   </span></span><br><span class="line"><span class="comment">        #exec: 执行命令的方法进行监测，如果其退出码不为0，则认为容器正常   </span></span><br><span class="line"><span class="comment">        #  command:   </span></span><br><span class="line"><span class="comment">        #    - cat   </span></span><br><span class="line"><span class="comment">        #    - /tmp/health   </span></span><br><span class="line"><span class="comment">        #也可以用这种方法   </span></span><br><span class="line"><span class="comment">        #tcpSocket: # 通过tcpSocket检查健康  </span></span><br><span class="line"><span class="comment">        #  port: number </span></span><br><span class="line">        <span class="attr">ports</span>:<span class="string"></span></span><br><span class="line">          <span class="meta">-</span> <span class="string">name: http # 名称</span></span><br><span class="line">            <span class="attr">containerPort</span>: <span class="string">8080 # 容器开发对外的端口 </span></span><br><span class="line">            <span class="attr">protocol</span>: <span class="string">TCP # 协议</span></span><br><span class="line">      <span class="attr">imagePullSecrets</span>: <span class="string"># 镜像仓库拉取密钥</span></span><br><span class="line">        <span class="meta">-</span> <span class="string">name: harbor-certification</span></span><br><span class="line">      <span class="attr">affinity</span>: <span class="string"># 亲和性调试</span></span><br><span class="line">        <span class="attr">nodeAffinity</span>: <span class="string"># 节点亲和力</span></span><br><span class="line">          <span class="attr">requiredDuringSchedulingIgnoredDuringExecution</span>: <span class="string"># pod 必须部署到满足条件的节点上</span></span><br><span class="line">            <span class="attr">nodeSelectorTerms</span>: <span class="string"># 节点满足任何一个条件就可以</span></span><br><span class="line">            <span class="meta">-</span> <span class="string">matchExpressions: # 有多个选项，则只有同时满足这些逻辑选项的节点才能运行 pod</span></span><br><span class="line">              <span class="meta">-</span> <span class="string">key: beta.kubernetes.io/arch</span></span><br><span class="line">                <span class="attr">operator</span>: <span class="string">In</span></span><br><span class="line">                <span class="attr">values</span>:<span class="string"></span></span><br><span class="line">                <span class="meta">-</span> <span class="string">amd64</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: extensions&#x2F;v1beta1   #接口版本</span><br><span class="line">kind: Deployment                 #接口类型</span><br><span class="line">metadata:</span><br><span class="line">  name: cango-demo               #Deployment名称</span><br><span class="line">  namespace: cango-prd           #命名空间</span><br><span class="line">  labels:</span><br><span class="line">    app: cango-demo              #标签</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">    strategy:</span><br><span class="line">      rollingUpdate:  ##由于replicas为3,则整个升级,pod个数在2-4个之间</span><br><span class="line">        maxSurge: 1      #滚动升级时会先启动1个pod</span><br><span class="line">        maxUnavailable: 1 #滚动升级时允许的最大Unavailable的pod个数</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: cango-demo  #模板名称必填</span><br><span class="line">    sepc: #定义容器模板，该模板可以包含多个容器</span><br><span class="line">      containers:</span><br><span class="line">        - name: cango-demo                                                           #镜像名称</span><br><span class="line">          image: swr.cn-east-2.myhuaweicloud.com&#x2F;cango-prd&#x2F;cango-demo:0.0.1-SNAPSHOT #镜像地址</span><br><span class="line">          command: [ &quot;&#x2F;bin&#x2F;sh&quot;,&quot;-c&quot;,&quot;cat &#x2F;etc&#x2F;config&#x2F;path&#x2F;to&#x2F;special-key&quot; ]    #启动命令</span><br><span class="line">          args:                                                                #启动参数</span><br><span class="line">            - &#39;-storage.local.retention&#x3D;$(STORAGE_RETENTION)&#39;</span><br><span class="line">            - &#39;-storage.local.memory-chunks&#x3D;$(STORAGE_MEMORY_CHUNKS)&#39;</span><br><span class="line">            - &#39;-config.file&#x3D;&#x2F;etc&#x2F;prometheus&#x2F;prometheus.yml&#39;</span><br><span class="line">            - &#39;-alertmanager.url&#x3D;http:&#x2F;&#x2F;alertmanager:9093&#x2F;alertmanager&#39;</span><br><span class="line">            - &#39;-web.external-url&#x3D;$(EXTERNAL_URL)&#39;</span><br><span class="line">          #如果command和args均没有写，那么用Docker默认的配置。</span><br><span class="line">          #如果command写了，但args没有写，那么Docker默认的配置会被忽略而且仅仅执行.yaml文件的command（不带任何参数的）。</span><br><span class="line">          #如果command没写，但args写了，那么Docker默认配置的ENTRYPOINT的命令行会被执行，但是调用的参数是.yaml中的args。</span><br><span class="line">          #如果如果command和args都写了，那么Docker默认的配置被忽略，使用.yaml的配置。</span><br><span class="line">          imagePullPolicy: IfNotPresent  #如果不存在则拉取</span><br><span class="line">          livenessProbe:       #表示container是否处于live状态。如果LivenessProbe失败，LivenessProbe将会通知kubelet对应的container不健康了。随后kubelet将kill掉container，并根据RestarPolicy进行进一步的操作。默认情况下LivenessProbe在第一次检测之前初始化值为Success，如果container没有提供LivenessProbe，则也认为是Success；</span><br><span class="line">            httpGet:</span><br><span class="line">              path: &#x2F;health #如果没有心跳检测接口就为&#x2F;</span><br><span class="line">              port: 8080</span><br><span class="line">              scheme: HTTP</span><br><span class="line">            initialDelaySeconds: 60 ##启动后延时多久开始运行检测</span><br><span class="line">            timeoutSeconds: 5</span><br><span class="line">            successThreshold: 1</span><br><span class="line">            failureThreshold: 5</span><br><span class="line">            readinessProbe:</span><br><span class="line">          readinessProbe:</span><br><span class="line">            httpGet:</span><br><span class="line">              path: &#x2F;health #如果没有心跳检测接口就为&#x2F;</span><br><span class="line">              port: 8080</span><br><span class="line">              scheme: HTTP</span><br><span class="line">            initialDelaySeconds: 30 ##启动后延时多久开始运行检测</span><br><span class="line">            timeoutSeconds: 5</span><br><span class="line">            successThreshold: 1</span><br><span class="line">            failureThreshold: 5</span><br><span class="line">          resources:              ##CPU内存限制</span><br><span class="line">            requests:</span><br><span class="line">              cpu: 2</span><br><span class="line">              memory: 2048Mi</span><br><span class="line">            limits:</span><br><span class="line">              cpu: 2</span><br><span class="line">              memory: 2048Mi</span><br><span class="line">          env:                    ##通过环境变量的方式，直接传递pod&#x3D;自定义Linux OS环境变量</span><br><span class="line">            - name: LOCAL_KEY     #本地Key</span><br><span class="line">              value: value</span><br><span class="line">            - name: CONFIG_MAP_KEY  #局策略可使用configMap的配置Key，</span><br><span class="line">              valueFrom:</span><br><span class="line">                configMapKeyRef:</span><br><span class="line">                  name: special-config   #configmap中找到name为special-config</span><br><span class="line">                  key: special.type      #找到name为special-config里data下的key</span><br><span class="line">          ports:</span><br><span class="line">            - name: http</span><br><span class="line">              containerPort: 8080 #对service暴露端口</span><br><span class="line">          volumeMounts:     #挂载volumes中定义的磁盘</span><br><span class="line">            - name: log-cache</span><br><span class="line">              mount: &#x2F;tmp&#x2F;log</span><br><span class="line">            - name: sdb       #普通用法，该卷跟随容器销毁，挂载一个目录</span><br><span class="line">              mountPath: &#x2F;data&#x2F;media</span><br><span class="line">            - name: nfs-client-root    #直接挂载硬盘方法，如挂载下面的nfs目录到&#x2F;mnt&#x2F;nfs</span><br><span class="line">              mountPath: &#x2F;mnt&#x2F;nfs</span><br><span class="line">            - name: example-volume-config  #高级用法第1种，将ConfigMap的log-script,backup-script分别挂载到&#x2F;etc&#x2F;config目录下的一个相对路径path&#x2F;to&#x2F;...下，如果存在同名文件，直接覆盖。</span><br><span class="line">              mountPath: &#x2F;etc&#x2F;config</span><br><span class="line">            - name: rbd-pvc                #高级用法第2中，挂载PVC(PresistentVolumeClaim)</span><br><span class="line"></span><br><span class="line">  #使用volume将ConfigMap作为文件或目录直接挂载，其中每一个key-value键值对都会生成一个文件，key为文件名，value为内容，</span><br><span class="line">  volumes:  # 定义磁盘给上面volumeMounts挂载</span><br><span class="line">    - name: log-cache</span><br><span class="line">      emptyDir: &#123;&#125;</span><br><span class="line">    - name: sdb  #挂载宿主机上面的目录</span><br><span class="line">      hostPath:</span><br><span class="line">        path: &#x2F;any&#x2F;path&#x2F;it&#x2F;will&#x2F;be&#x2F;replaced</span><br><span class="line">    - name: example-volume-config  # 供ConfigMap文件内容到指定路径使用</span><br><span class="line">      configMap:</span><br><span class="line">        name: example-volume-config  #ConfigMap中名称</span><br><span class="line">        items:</span><br><span class="line">          - key: log-script           #ConfigMap中的Key</span><br><span class="line">            path: path&#x2F;to&#x2F;log-script  #指定目录下的一个相对路径path&#x2F;to&#x2F;log-script</span><br><span class="line">          - key: backup-script        #ConfigMap中的Key</span><br><span class="line">            path: path&#x2F;to&#x2F;backup-script  #指定目录下的一个相对路径path&#x2F;to&#x2F;backup-script</span><br><span class="line">    - name: nfs-client-root         #供挂载NFS存储类型</span><br><span class="line">      nfs:</span><br><span class="line">        server: 10.42.0.55          #NFS服务器地址</span><br><span class="line">        path: &#x2F;opt&#x2F;public           #showmount -e 看一下路径</span><br><span class="line">    - name: rbd-pvc                 #挂载PVC磁盘</span><br><span class="line">      persistentVolumeClaim:</span><br><span class="line">        claimName: rbd-pvc1         #挂载已经申请的pvc磁盘</span><br></pre></td></tr></table></figure><h4 id="Service-yaml"><a href="#Service-yaml" class="headerlink" title="Service yaml"></a>Service yaml</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion</span>: <span class="string">v1 # 指定api版本，此值必须在kubectl api-versions中 </span></span><br><span class="line"><span class="attr">kind</span>: <span class="string">Service # 指定创建资源的角色/类型 </span></span><br><span class="line"><span class="attr">metadata</span>: <span class="string"># 资源的元数据/属性</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">demo # 资源的名字，在同一个namespace中必须唯一</span></span><br><span class="line">  <span class="attr">namespace</span>: <span class="string">default # 部署在哪个namespace中</span></span><br><span class="line">  <span class="attr">labels</span>: <span class="string"># 设定资源的标签</span></span><br><span class="line">    <span class="attr">app</span>: <span class="string">demo</span></span><br><span class="line"><span class="attr">spec</span>: <span class="string"># 资源规范字段</span></span><br><span class="line">  <span class="attr">type</span>: <span class="string">ClusterIP # ClusterIP 类型</span></span><br><span class="line">  <span class="attr">ports</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">-</span> <span class="string">port: 8080 # service 端口</span></span><br><span class="line">      <span class="attr">targetPort</span>: <span class="string">http # 容器暴露的端口</span></span><br><span class="line">      <span class="attr">protocol</span>: <span class="string">TCP # 协议</span></span><br><span class="line">      <span class="attr">name</span>: <span class="string">http # 端口名称</span></span><br><span class="line">  <span class="attr">selector</span>: <span class="string"># 选择器</span></span><br><span class="line">    <span class="attr">app</span>: <span class="string">demo</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成yaml模板</span></span><br><span class="line"><span class="attr">kubectl</span> <span class="string">create deployment java-demo --image=harry82/tomcat:v1 --dry-run=client -o yaml &gt; java-demo.yaml</span></span><br><span class="line"><span class="attr">kubectl</span> <span class="string">expose deployment java-demo --port=80 --target-port=8080 --type=NodePort --dry-run=client -o yaml &gt;svc.yaml</span></span><br><span class="line"><span class="comment">#部署pod，svc</span></span><br><span class="line"><span class="attr">kubectl</span> <span class="string">apply -f java-demo.yaml --record</span></span><br><span class="line"><span class="attr">kubectl</span> <span class="string">apply -f svc.yaml</span></span><br><span class="line"><span class="comment">#查看历史版本</span></span><br><span class="line"><span class="attr">kubectl</span> <span class="string">rollout history deployment/java-demo</span></span><br><span class="line"><span class="comment">#回顾到上一个版本</span></span><br><span class="line"><span class="attr">kubectl</span> <span class="string">rollout undo deployment/java-demo</span></span><br><span class="line"><span class="comment">#回滚到指定版本</span></span><br><span class="line"><span class="attr">kubectl</span> <span class="string">rollout undo deployment/java-demo --to-revision=2</span></span><br><span class="line"><span class="comment">#创建 Deployment 的时候使用了--record参数可以记录命令，查看每次revision 的变化。查看单个revision 的详细信息：</span></span><br><span class="line"><span class="attr">kubectl</span> <span class="string">rollout history deployment java-demo --revision=2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubectl create deployment nginx --image&#x3D;nginx</span><br><span class="line">kubectl scale deployment nginx --replicas&#x3D;2</span><br><span class="line">kubectl delete deployment nginx</span><br><span class="line">kubectl describe  pods nginx</span><br><span class="line">kubectl expose deployment nginx --port&#x3D;80 --type&#x3D;NodePort</span><br><span class="line">kubectl delete svc nginx</span><br><span class="line">kubectl get pv</span><br></pre></td></tr></table></figure><p>deployment根据Pod的标签关联到Pod,是为了管理pod的生命周期</p><p>service根据Pod的标签关联到pod,是为了让外部访问到pod,给pod做负载均衡</p><p>Service 做服务发现 指定 Deployment 或者特定集合 Pod 的网络层抽象</p><h4 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#master节点安装nfs</span><br><span class="line">[root@k8s-master nginx]# yum -y install nfs-utils</span><br><span class="line">#创建nfs目录</span><br><span class="line">[root@k8s-master nginx]# mkdir -p &#x2F;nfs&#x2F;data&#x2F;</span><br><span class="line">#修改权限</span><br><span class="line">[root@k8s-master nginx]# chmod -R 777 &#x2F;nfs&#x2F;data</span><br><span class="line">#编辑export文件,这个文件就是nfs默认的配置文件</span><br><span class="line">[root@k8s-master nginx]# vim &#x2F;etc&#x2F;exports</span><br><span class="line">&#x2F;home&#x2F;data *(rw,no_root_squash,sync)</span><br><span class="line">#配置生效</span><br><span class="line">[root@k8s-master nginx]# exportfs -r</span><br><span class="line">#查看生效</span><br><span class="line">[root@k8s-master nginx]# exportfs</span><br><span class="line">&#x2F;home&#x2F;data       &lt;world&gt;</span><br><span class="line">#启动rpcbind、nfs服务</span><br><span class="line">[root@k8s-master nginx]# systemctl restart rpcbind &amp;&amp; systemctl enable rpcbind</span><br><span class="line">[root@k8s-master nginx]# systemctl restart nfs &amp;&amp; systemctl enable nfs</span><br><span class="line">Created symlink from &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;nfs-server.service to &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;nfs-server.service.</span><br><span class="line">#查看 RPC 服务的注册状况</span><br><span class="line">[root@k8s-master nginx]# rpcinfo -p localhost</span><br><span class="line">   program vers proto   port  service</span><br><span class="line">    100000    4   tcp    111  portmapper</span><br><span class="line">    100000    3   tcp    111  portmapper</span><br><span class="line">    100000    2   tcp    111  portmapper</span><br><span class="line">    100000    4   udp    111  portmapper</span><br><span class="line"></span><br><span class="line">#showmount测试</span><br><span class="line">[root@k8s-master nginx]# showmount -e 192.168.0.66</span><br><span class="line"> Export list for 192.168.0.66:</span><br><span class="line"> &#x2F;home&#x2F;data *</span><br><span class="line"> </span><br><span class="line">各节点安装并启用nfs</span><br><span class="line">yum install nfs-utils</span><br><span class="line">systemctl start nfs &amp; systemctl enable nfs</span><br><span class="line">systemctl start rpcbind &amp; systemctl enable rpcbind</span><br></pre></td></tr></table></figure><h4 id="创建PV"><a href="#创建PV" class="headerlink" title="创建PV"></a>创建PV</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#创建前我们先在master节点 mkdir &#x2F;home&#x2F;data 创建出一个data子目录供pv使用</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: share</span><br><span class="line">spec:</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 10Gi</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">  persistentVolumeReclaimPolicy: Recycle</span><br><span class="line">  volumeMode: Filesystem</span><br><span class="line">  nfs:</span><br><span class="line">    server: 192.168.102.160</span><br><span class="line">    path: &quot;&#x2F;home&#x2F;data&quot;</span><br></pre></td></tr></table></figure><p><strong>PV 的访问模式（accessModes）有三种：</strong><br> ReadWriteOnce（RWO）：是最基本的方式，可读可写，但只支持被单个 Pod 挂载。<br> ReadOnlyMany（ROX）：可以以只读的方式被多个 Pod 挂载。<br> ReadWriteMany（RWX）：这种存储可以以读写的方式被多个 Pod 共享。</p><p><strong>PV 的回收策略（persistentVolumeReclaimPolicy，即 PVC 释放卷的时候 PV 该如何操作）也有三种：</strong><br> Retain，不清理, 保留 Volume（需要手动清理）<br> Recycle，删除数据，即 rm -rf /volume/*（只有 NFS 和 HostPath 支持）<br> Delete，删除存储资源，比如删除 AWS EBS 卷（只有 AWS EBS, GCE PD, Azure Disk 和 Cinder 支持）<br> PVC释放卷是指用户删除一个PVC对象时，那么与该PVC对象绑定的PV就会被释放。</p><p><strong>PersistentVolume有四种状态：</strong><br> Available: 可用状态<br> Bound: 绑定到PVC<br> Released: PVC被删掉，但是尚未回收<br> Failed : 自动回收失败</p><h4 id="创建PVC"><a href="#创建PVC" class="headerlink" title="创建PVC"></a>创建PVC</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: share</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 1Gi</span><br></pre></td></tr></table></figure><h4 id="创建pod并使用pvc存储资源"><a href="#创建pod并使用pvc存储资源" class="headerlink" title="创建pod并使用pvc存储资源"></a>创建pod并使用pvc存储资源</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#deploy</span><br><span class="line">apiVersion: apps&#x2F;v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-nginx</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nfs-nginx</span><br><span class="line">  replicas: 2</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nfs-nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx-web</span><br><span class="line">        image: nginx:latest</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - mountPath: &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</span><br><span class="line">          name: html</span><br><span class="line">      volumes:</span><br><span class="line">      - name: html</span><br><span class="line">        persistentVolumeClaim:</span><br><span class="line">          claimName: share</span><br><span class="line">---</span><br><span class="line">#service</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-nginx</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 80</span><br><span class="line">    nodePort: 31681</span><br><span class="line">  selector:</span><br><span class="line">    app: nfs-nginx</span><br></pre></td></tr></table></figure><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我们在&#x2F;home&#x2F;data目录创建了一个index.html文件,通过集群访问。</span><br><span class="line">pod销毁重建</span><br><span class="line">kubectl delete -f nginx.yaml</span><br><span class="line">kubectl apply -f nginx.yaml</span><br><span class="line">再次访问index.html，依旧可以访问到，说明文件未丢失。</span><br></pre></td></tr></table></figure><h4 id="busybox"><a href="#busybox" class="headerlink" title="busybox"></a>busybox</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: busybox</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: busybox</span><br><span class="line">    image: busybox</span><br><span class="line">    command:</span><br><span class="line">      - sleep</span><br><span class="line">      - &quot;3600&quot;</span><br><span class="line">    volumeMounts:</span><br><span class="line">        - name: share</span><br><span class="line">          mountPath: &quot;&#x2F;share&quot;</span><br><span class="line">  volumes:</span><br><span class="line">  - name: share</span><br><span class="line">    persistentVolumeClaim:</span><br><span class="line">      claimName: share</span><br></pre></td></tr></table></figure><h4 id="Kubernetes-Ingress配置HTTPS"><a href="#Kubernetes-Ingress配置HTTPS" class="headerlink" title="Kubernetes Ingress配置HTTPS"></a>Kubernetes Ingress配置HTTPS</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#https:&#x2F;&#x2F;blog.csdn.net&#x2F;lwlfox&#x2F;article&#x2F;details&#x2F;106219412</span><br><span class="line">[root@master ~]# unzip 3408668__ihdou.com_nginx.zip </span><br><span class="line">[root@master ~]# mv 3408668__ihdou.com.pem tls.crt</span><br><span class="line">[root@master ~]# mv 3408668__ihdou.com.key tls.key</span><br><span class="line">[root@master ~]# kubectl create secret tls tls-secret --cert .&#x2F;tls.crt --key .&#x2F;tls.key</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# more ingress-https.yaml </span><br><span class="line">apiVersion: extensions&#x2F;v1beta1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-nginx</span><br><span class="line">  annotations:</span><br><span class="line">    nginx.ingress.kubernetes.io&#x2F;rewrite-target: &#x2F;</span><br><span class="line">    nginx.ingress.kubernetes.io&#x2F;ssl-redirect: &#39;true&#39;</span><br><span class="line">    nginx.ingress.kubernetes.io&#x2F;proxy-connect-timeout: &quot;600&quot; </span><br><span class="line">    nginx.ingress.kubernetes.io&#x2F;proxy-read-timeout: &quot;600&quot;</span><br><span class="line">    nginx.ingress.kubernetes.io&#x2F;proxy-send-timeout: &quot;600&quot;</span><br><span class="line">spec:</span><br><span class="line">  tls:</span><br><span class="line">  - hosts: </span><br><span class="line">    - &#39;k8s.ihdou.com&#39;</span><br><span class="line">    secretName: tls-secret</span><br><span class="line">  rules:</span><br><span class="line">  - host: k8s.ihdou.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - backend:</span><br><span class="line">          serviceName: nfs-nginx</span><br><span class="line">          servicePort: 80</span><br><span class="line">        path: &#x2F;</span><br></pre></td></tr></table></figure><h4 id="istio"><a href="#istio" class="headerlink" title="istio"></a>istio</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_44144334&#x2F;article&#x2F;details&#x2F;107788292</span><br><span class="line">#自动注入</span><br><span class="line">kubectl label namespace default istio-injection&#x3D;enabled</span><br><span class="line">#取消注入</span><br><span class="line">kubectl label namespace default istio-injection&#x3D;disabled  --overwrite&#x3D;true</span><br><span class="line">#手动注入</span><br><span class="line">istioctl kube-inject -f nginx.yaml -o nginx.istio.injected.yaml</span><br><span class="line">#查看哪些namespace可以注入</span><br><span class="line"> kubectl get namespace -L istio-injection</span><br><span class="line">#在失败的 pod 的 deployment 上运行 kubectl describe -n namespace deployment name。通常能在事件中看到调用注入 webhook 失败的原因。</span><br><span class="line">kubectl describe -n default deployment nfs-nginx</span><br><span class="line">#查看kiali端口</span><br><span class="line">kubectl describe svc -n istio-system kiali </span><br><span class="line">#注入失败http:&#x2F;&#x2F;devops.weiminginfo.com&#x2F;cloud&#x2F;1764.html</span><br><span class="line"></span><br><span class="line">istioctl manifest install --set profile&#x3D;demo</span><br><span class="line">istioctl manifest generate --set profile&#x3D;demo &gt; $HOME&#x2F;generated-manifest.yaml</span><br><span class="line">istioctl verify-install -f $HOME&#x2F;generated-manifest.yaml</span><br><span class="line">istioctl manifest generate --set profile&#x3D;demo | kubectl delete -f -</span><br></pre></td></tr></table></figure><h4 id="prometheus-grafana"><a href="#prometheus-grafana" class="headerlink" title="prometheus grafana"></a>prometheus grafana</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#https://www.cnblogs.com/liufei1983/p/10460590.html</span></span><br><span class="line"><span class="comment"># 验证prometheus  service 已经运行：</span></span><br><span class="line"><span class="meta">[root@master</span> <span class="string">~]# kubectl -n istio-system get svc prometheus</span></span><br><span class="line"><span class="attr">NAME</span>         <span class="string">TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE</span></span><br><span class="line"><span class="attr">prometheus</span>   <span class="string">ClusterIP   10.102.202.142   &lt;none&gt;        9090/TCP   46h</span></span><br><span class="line"><span class="comment">#验证Grafana service运行：</span></span><br><span class="line"><span class="meta">[root@master</span> <span class="string">~]# kubectl -n istio-system get svc grafana</span></span><br><span class="line"><span class="attr">NAME</span>      <span class="string">TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE</span></span><br><span class="line"><span class="attr">grafana</span>   <span class="string">ClusterIP   10.110.41.188   &lt;none&gt;        3000/TCP   46h</span></span><br><span class="line"><span class="comment">#本地访问grafana</span></span><br><span class="line"><span class="meta">1.把本地3000端口转发到grafana</span> <span class="string">pod的3000端口：</span></span><br><span class="line"><span class="meta">[root@master</span> <span class="string">~]# kubectl -n istio-system port-forward $(kubectl -n istio-system get pod -l app=grafana -o jsonpath=&#x27;&#123;.items[0].metadata.name&#125;&#x27;) 3000:3000 &amp;</span></span><br><span class="line"><span class="meta">[1]</span> <span class="string">17448</span></span><br><span class="line"><span class="meta">[root@master</span> <span class="string">~]# Forwarding from 127.0.0.1:3000 -&gt; 3000</span></span><br><span class="line"><span class="attr">Forwarding</span> <span class="string">from [::1]:3000 -&gt; 3000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">2.在本地的浏览器中访问</span>   <span class="string">http://localhost:3000/dashboard/db/istio-mesh-dashboard</span></span><br><span class="line"><span class="meta">[root@master</span> <span class="string">~]#  curl http://localhost:3000/dashboard/db/istio-mesh-dashboard</span></span><br><span class="line"><span class="attr">Handling</span> <span class="string">connection for 3000</span></span><br><span class="line"><span class="meta">&lt;a</span> <span class="string">href=&quot;/d/G8wLrJIZk/istio-mesh-dashboard?&quot;&gt;Moved Permanently&lt;/a&gt;.</span></span><br><span class="line"><span class="attr">上面的port-forward只能本地访问，不能从外部访问。</span></span><br><span class="line"><span class="comment"># 如何从外部访问service：</span></span><br><span class="line"> <span class="attr">grafana</span>:<span class="string">默认是clusterIP，需要改成NodePort，暴露一个在30000 ~32767范围内的端口。</span></span><br><span class="line"> <span class="attr">kubectl</span> <span class="string">get svc -n istio-system</span></span><br><span class="line"> <span class="attr">kubectl</span> <span class="string">edit svc grafana -n istio-system   #修改相应nodeport配置</span></span><br><span class="line"> <span class="attr">kubectl</span> <span class="string">edit svc -n istio-system prometheus #修改相应nodeport配置</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/hzq82/img/master/img/istio-20201113-1.png"></p><p><img src="https://raw.githubusercontent.com/hzq82/img/master/img/istio-20201113-2.png"></p><p><strong>从外网访问grafana 和 Prometheus：</strong></p><p><a href="http://192.168.102.160:32333/d/1/istio-mesh-dashboard?orgId=1">http://192.168.102.160:32333/d/1/istio-mesh-dashboard?orgId=1</a></p><p><a href="http://192.168.102.160:32339/graph">http://192.168.102.160:32339/graph</a></p><h4 id="istio实现对外暴露服务"><a href="#istio实现对外暴露服务" class="headerlink" title="istio实现对外暴露服务"></a>istio实现对外暴露服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#https:&#x2F;&#x2F;www.cnblogs.com&#x2F;boshen-hzb&#x2F;p&#x2F;10679863.html</span><br><span class="line">kubectl get gateway --all-namespaces</span><br><span class="line">kubectl get virtualservices</span><br><span class="line">kubectl get destinationrules.networking.istio.io</span><br><span class="line">kubectl get svc istio-ingressgateway -n istio-system</span><br><span class="line">export PATH&#x3D;$PWD&#x2F;bin:$PATH</span><br><span class="line">kubectl label namespace default istio-injection&#x3D;enabled</span><br><span class="line">kubectl edit  service istio-ingressgateway -n istio-system</span><br><span class="line">spec:</span><br><span class="line">  clusterIP: 10.10.54.71</span><br><span class="line">  externalTrafficPolicy: Cluster</span><br><span class="line">  externalIPs: </span><br><span class="line">  - 192.168.102.91</span><br><span class="line">  ports:</span><br></pre></td></tr></table></figure><h4 id="kubernetes集群部署redis5-0-6单机版"><a href="#kubernetes集群部署redis5-0-6单机版" class="headerlink" title="kubernetes集群部署redis5.0.6单机版"></a>kubernetes集群部署redis5.0.6单机版</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;160959892</span><br></pre></td></tr></table></figure><h4 id="configmap"><a href="#configmap" class="headerlink" title="configmap"></a>configmap</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;2937cf33d088</span><br><span class="line">kubectl describe configmap nginx-config</span><br><span class="line">kubectl get configmap nginx-config -o yaml</span><br></pre></td></tr></table></figure><h4 id="initcontainer"><a href="#initcontainer" class="headerlink" title="initcontainer"></a>initcontainer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于一个Pod里的存储卷是共享的，所以Init Container里产生的数据可以被主容器使用到。</span><br></pre></td></tr></table></figure><h4 id="NFS-Provisioner"><a href="#NFS-Provisioner" class="headerlink" title="NFS Provisioner"></a>NFS Provisioner</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_32641153&#x2F;article&#x2F;details&#x2F;94730358</span><br></pre></td></tr></table></figure><h4 id="harbor"><a href="#harbor" class="headerlink" title="harbor"></a>harbor</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;blog.csdn.net&#x2F;u014042047&#x2F;article&#x2F;details&#x2F;108771161</span><br><span class="line">192.168.102.156</span><br><span class="line">cd harbor&#x2F;</span><br><span class="line">docker-compose up -d</span><br><span class="line">docker-compose stop</span><br></pre></td></tr></table></figure><h4 id="EFK"><a href="#EFK" class="headerlink" title="EFK"></a>EFK</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#https:&#x2F;&#x2F;mp.weixin.qq.com&#x2F;s&#x2F;SoelIGIT5lQSgJlE4MYFjg</span><br><span class="line">kubectl apply -f kube-logging.yaml</span><br><span class="line">kubectl apply -f elasticsearch_svc.yaml</span><br><span class="line">kubectl get services --namespace&#x3D;kube-logging</span><br><span class="line">kubectl apply -f serviceaccount.yaml</span><br><span class="line">kubectl apply -f rbac.yaml</span><br><span class="line">kubectl apply -f deployment.yaml</span><br><span class="line">kubectl apply -f class.yaml</span><br><span class="line">kubectl apply -f elasticsaerch-statefulset.yaml</span><br><span class="line">kubectl get pods -n kube-logging</span><br><span class="line">kubectl apply -f kibana.yaml</span><br><span class="line">kubectl edit svc kibana -n kube-logging</span><br><span class="line">kubectl get svc -n kube-logging</span><br><span class="line">curl http:&#x2F;&#x2F;es-cluster-0.elasticsearch.kube-logging.svc.cluster.local:9200&#x2F;_cat&#x2F;health?v</span><br><span class="line">kubectl get cronjob -n kube-logging</span><br><span class="line">kubectl get jobs -n kube-logging</span><br><span class="line">https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_30607029&#x2F;article&#x2F;details&#x2F;99925796 #定时删除日志，保留3天</span><br></pre></td></tr></table></figure><h4 id="Prometheus-Operator监控kubernetes集群"><a href="#Prometheus-Operator监控kubernetes集群" class="headerlink" title="Prometheus-Operator监控kubernetes集群"></a>Prometheus-Operator监控kubernetes集群</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;a687ab2d6ede</span><br><span class="line">kubectl  get pod,svc -n monitoring|grep grafana</span><br></pre></td></tr></table></figure><h4 id="pod-管理"><a href="#pod-管理" class="headerlink" title="pod 管理"></a>pod 管理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_44571270&#x2F;article&#x2F;details&#x2F;104823185</span><br><span class="line">#容器升级更新</span><br><span class="line">kubectl set image deployment&#x2F;product product&#x3D;registry.ihdou.com&#x2F;4.0&#x2F;product</span><br><span class="line">#查看容器升级更新进程</span><br><span class="line">kubectl -n default rollout status deployment&#x2F;product</span><br><span class="line">#回滚到上一个版本</span><br><span class="line">kubectl rollout undo deployments&#x2F;product -n default</span><br><span class="line">#查看是否回滚</span><br><span class="line">kubectl -n default rollout status deployments&#x2F;product</span><br><span class="line">#查看历史版本</span><br><span class="line">kubectl rollout history deploy&#x2F;product</span><br><span class="line">#查看某个版本详情</span><br><span class="line">kubectl rollout history deployment&#x2F;product --revision&#x3D;8</span><br><span class="line">#回滚至某个版本</span><br><span class="line">kubectl rollout undo deployment&#x2F;product  --to-revision&#x3D;2  -n default</span><br><span class="line">#删除不能正常删除的pod</span><br><span class="line">kubectl delete pod product-675894f45b-s9fjz –grace-period&#x3D;0 --force -n default </span><br><span class="line">for i in &#96;kubectl get pod -n default|awk &#39;&#123;print $1&#125;&#39;|grep product-675894f45b-s9fjz&#96;;do kubectl delete pod $i –grace-period&#x3D;0 --force -n default;done</span><br></pre></td></tr></table></figure><h4 id="Metrics-Server"><a href="#Metrics-Server" class="headerlink" title="Metrics Server"></a>Metrics Server</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.mydlq.club&#x2F;article&#x2F;77&#x2F;</span><br></pre></td></tr></table></figure><h4 id="kiali安装使用"><a href="#kiali安装使用" class="headerlink" title="kiali安装使用"></a>kiali安装使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#https:&#x2F;&#x2F;blog.csdn.net&#x2F;yin0501&#x2F;article&#x2F;details&#x2F;108876303</span><br><span class="line">cd &#x2F;root&#x2F;istio-1.8.1&#x2F;samples&#x2F;addons</span><br><span class="line">I copied the CustomResourceDefinition from the samples&#x2F;addons&#x2F;kiali.yaml in to the file samples&#x2F;addons&#x2F;crd.yaml and ran that in first</span><br><span class="line"> ktl apply -f crd.yaml</span><br><span class="line"> ktl apply -f kiali.yaml </span><br><span class="line">kubectl port-forward --address 0.0.0.0 kiali-667b888c56-fp9jx 20001 -n istio-system</span><br><span class="line">启动后会报错</span><br><span class="line">kubectl apply -f samples&#x2F;addons</span><br><span class="line">kubectl apply -f samples&#x2F;addons&#x2F;extras</span><br></pre></td></tr></table></figure><h4 id="Grafana修改密码"><a href="#Grafana修改密码" class="headerlink" title="Grafana修改密码"></a>Grafana修改密码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">找到部署的节点，按照下面步骤操作</span><br><span class="line">https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_38645718&#x2F;article&#x2F;details&#x2F;86066651</span><br></pre></td></tr></table></figure><h4 id="k8s–pod的状态为evicted"><a href="#k8s–pod的状态为evicted" class="headerlink" title="k8s–pod的状态为evicted"></a>k8s–pod的状态为evicted</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;blog.csdn.net&#x2F;zzq900503&#x2F;article&#x2F;details&#x2F;83788152</span><br><span class="line">eviction，即驱赶的意思，意思是当节点出现异常时，kubernetes将有相应的机制驱赶该节点上的Pod。</span><br><span class="line">多见于资源不足时导致的驱赶。</span><br><span class="line">kubectl get pods | grep Evicted | awk &#39;&#123;print $1&#125;&#39; | xargs kubectl delete pod</span><br></pre></td></tr></table></figure><h4 id="k8s节点资源预留与-pod-驱逐"><a href="#k8s节点资源预留与-pod-驱逐" class="headerlink" title="k8s节点资源预留与 pod 驱逐"></a>k8s节点资源预留与 pod 驱逐</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;5dcf04e8d56b</span><br><span class="line">https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;4c0763967b3c</span><br><span class="line">使用建议:</span><br><span class="line">  如果资源充足，可将QoS pods类型均设置为Guaranteed。用计算资源换业务性能和稳定性，减少排查问题时间和成本。</span><br><span class="line">  如果想更好的提高资源利用率，业务服务可以设置为Guaranteed，而其他服务根据重要程度可分别设置为Burstable或Best-Effort，例如filebeat。</span><br><span class="line">  不支持swap，当前的QoS策略假设swap已被禁止。</span><br><span class="line">Guaranteed：pod中的所有容器都必须对cpu和memory同时设置limits，如果有一个容器要设置requests，那么所有容器都要设置，并设置参数同limits一致，那么这个pod的QoS就是Guaranteed级别。</span><br><span class="line">Burstable: pod中只要有一个容器的requests和limits的设置不相同，该pod的QoS即为Burstable。</span><br><span class="line">Best-Effort：如果对于全部的resources来说requests与limits均未设置，该pod的QoS即为Best-Effort。</span><br><span class="line">QoS pods被kill掉的场景与顺序</span><br><span class="line">    Best-Effort 类型的pods：系统用完了全部内存时，该类型pods会最先被kill掉。</span><br><span class="line">    Burstable类型pods：系统用完了全部内存，且没有Best-Effort container可以被kill时，该类型pods会被kill掉。</span><br><span class="line">    Guaranteed pods：系统用完了全部内存、且没有Burstable与Best-Effort container可以被kill，该类型的pods会被kill掉。</span><br><span class="line">    注：如果pod进程因使用超过预先设定的limites而非Node资源紧张情况，系统倾向于在其原所在的机器上重启该container或本机或其他重新创建一个pod。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="rancher"><a href="#rancher" class="headerlink" title="rancher"></a>rancher</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;6ee865d396d3</span><br><span class="line">https:&#x2F;&#x2F;blog.zhenglin.work&#x2F;k8s&#x2F;deploy_app_in_rancher.html</span><br><span class="line">https:&#x2F;&#x2F;www.cnblogs.com&#x2F;lfl17718347843&#x2F;p&#x2F;13679458.html</span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;www.sohu.com&#x2F;a&#x2F;229885303_262549</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;集群常用命令&quot;&gt;&lt;a href=&quot;#集群常用命令&quot; class=&quot;headerlink&quot; title=&quot;集群常用命令&quot;&gt;&lt;/a&gt;集群常用命令&lt;/h4&gt;&lt;figure class=&quot;highlight properties&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;kubectl&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;create deployment java-demo --image=harry82/tomcat:v1 --dry-run=client -o yaml &amp;gt; java-demo.yaml&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;kubectl&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;expose deployment java-demo --port=80 --target-port=8080 --type=NodePort --dry-run=client -o yaml &amp;gt;svc.yaml&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;kubectl&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;get pod -o wide&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;kubectl&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;desribe pod nginx-f89759699-gjgbn&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;kubectl&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;get ep #查看svc关联pod&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;kubectl&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;create deployment nginx --image=nginx&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;kubectl&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;get cm&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;kubectl&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;describe cm petclinic-config&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;kubectl&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;logs [podName] #注意如果pod里容器大于1,则不能使用这种方法访问&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;kubectl&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;logs -f &amp;lt;pod-name&amp;gt; # 实时查看日志&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;kubectl&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;log myapp-pod -c test #查看容器日志（如果pod里大于1个容器，那么要加-c [容器名称]）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;kubectl&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;delete pod fluentd-bq8px -n kube-logging --grace-period=0 --force  #强制删除无法删除的pod&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;kubectl&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;logs --tail 200 kube-apiserver-master  -n kube-system&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;K8s-部署java应用&quot;&gt;&lt;a href=&quot;#K8s-部署java应用&quot; class=&quot;headerlink&quot; title=&quot;K8s 部署java应用&quot;&gt;&lt;/a&gt;K8s 部署java应用&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;https:&amp;#x2F;&amp;#x2F;192.168.102.160:30001&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="ops" scheme="http://yoursite.com/categories/ops/"/>
    
    
    <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>docker基础</title>
    <link href="http://yoursite.com/2020/11/02/docker/"/>
    <id>http://yoursite.com/2020/11/02/docker/</id>
    <published>2020-11-02T03:00:00.000Z</published>
    <updated>2020-11-02T03:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="docker是什么"><a href="#docker是什么" class="headerlink" title="docker是什么"></a>docker是什么</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Docker 到底是什么，要解决什么问题，好处又在哪里？</span><br><span class="line">软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？</span><br><span class="line">虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。</span><br><span class="line">虽然用户可以通过虚拟机还原软件的原始环境。</span><br><span class="line">（1）资源占用多</span><br><span class="line">（2）冗余步骤多</span><br><span class="line">（3）启动慢</span><br><span class="line">由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。</span><br><span class="line">Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离</span><br><span class="line">（1）启动快</span><br><span class="line">（2）资源占用少</span><br><span class="line">（3）体积小</span><br><span class="line">总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。</span><br><span class="line">Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。</span><br><span class="line">Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</span><br><span class="line"></span><br><span class="line">Docker 的主要用途，目前有三大类。</span><br><span class="line">（1）提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</span><br><span class="line">（2）提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</span><br><span class="line">（3）组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</span><br><span class="line"></span><br><span class="line">Docker 是一个开源的商业产品，有两个版本：社区版（Community Edition，缩写为 CE）和企业版（Enterprise Edition，缩写为 EE）。企业版包含了一些收费服务。</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#更新yum包</span></span><br><span class="line"><span class="attr">yum</span> <span class="string">update </span></span><br><span class="line"><span class="comment">#删除之前安装的版本</span></span><br><span class="line"><span class="attr">yum</span> <span class="string">remove docker docker-common docker-selinux docker-engine </span></span><br><span class="line"><span class="comment"># yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</span></span><br><span class="line"><span class="attr">yum</span> <span class="string">install -y yum-utils device-mapper-persistent-data lvm2 </span></span><br><span class="line"><span class="comment">#设置yum源</span></span><br><span class="line"><span class="meta">yum-config-manager</span> <span class="string">--add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span></span><br><span class="line"><span class="comment">#查看docker版本，一般使用稳定版</span></span><br><span class="line"><span class="attr">yum</span> <span class="string">list docker-ce --showduplicates | sort -r</span></span><br><span class="line"><span class="comment">#安装docker，默认安装最新版本，安装某特定版本需增加版本号（如18.06.3.ce-3.el7）</span></span><br><span class="line"><span class="attr">yum</span> <span class="string">install docker-ce-18.06.3.ce</span></span><br><span class="line"><span class="comment">#启动docker</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">start docker </span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">enable docker</span></span><br><span class="line"><span class="comment">#查看版本</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">version|info</span></span><br><span class="line"><span class="meta">[root@my-host</span> <span class="string">~]# docker version</span></span><br><span class="line"><span class="attr">Client</span>:<span class="string"></span></span><br><span class="line"> <span class="attr">Version</span>:      <span class="string">17.09.1-ce</span></span><br><span class="line"> <span class="attr">API</span> <span class="string">version:  1.32</span></span><br><span class="line"> <span class="attr">Go</span> <span class="string">version:   go1.8.3</span></span><br><span class="line"> <span class="attr">Git</span> <span class="string">commit:   19e2cf6</span></span><br><span class="line"> <span class="attr">Built</span>:        <span class="string">Thu Dec  7 22:23:40 2017</span></span><br><span class="line"> <span class="meta">OS/Arch</span>:      <span class="string">linux/amd64</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Server</span>:<span class="string"></span></span><br><span class="line"> <span class="attr">Version</span>:      <span class="string">17.09.1-ce</span></span><br><span class="line"> <span class="attr">API</span> <span class="string">version:  1.32 (minimum version 1.12)</span></span><br><span class="line"> <span class="attr">Go</span> <span class="string">version:   go1.8.3</span></span><br><span class="line"> <span class="attr">Git</span> <span class="string">commit:   19e2cf6</span></span><br><span class="line"> <span class="attr">Built</span>:        <span class="string">Thu Dec  7 22:25:03 2017</span></span><br><span class="line"> <span class="meta">OS/Arch</span>:      <span class="string">linux/amd64</span></span><br><span class="line"> <span class="attr">Experimental</span>: <span class="string">false</span></span><br></pre></td></tr></table></figure><h3 id="docker-架构"><a href="#docker-架构" class="headerlink" title="docker 架构"></a>docker 架构</h3><p><img src="https://raw.githubusercontent.com/hzq82/img/master/img/docker.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Docker使用了C&#x2F;S体系架构，Docker客户端与Docker守护进程通信，Docker守护进程负责构建，运行和分发Docker容器。Docker客户端和守护进程可以在同一个系统上运行，也可以将Docker客户端连接到远程Docker守护进程。</span><br></pre></td></tr></table></figure><h3 id="docker网络"><a href="#docker网络" class="headerlink" title="docker网络"></a>docker网络</h3><p>​       Docker使用Linux桥接（参考<a href="https://www.jianshu.com/p/f86d4b88777d">《Linux虚拟网络技术》</a>），在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。</p><p>Docker网桥是宿主机虚拟出来的，并不是真实存在的网络设备，外部网络是无法寻址到的，这也意味着外部网络无法通过直接Container-IP访问到容器。如果容器希望外部访问能够访问到，可以通过映射容器端口到宿主主机（端口映射），即docker run创建容器时候通过 -p 或 -P 参数来启用，访问容器的时候就通过[宿主机IP]:[容器端口]访问容器。</p><h3 id="docker-常用命令"><a href="#docker-常用命令" class="headerlink" title="docker 常用命令"></a>docker 常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker ps 查看当前正在运行的容器</span><br><span class="line">docker ps -a 查看所有容器的状态</span><br><span class="line">docker start&#x2F;stop id&#x2F;name 启动&#x2F;停止某个容器</span><br><span class="line">docker attach id 进入某个容器(使用exit退出后容器也跟着停止运行)</span><br><span class="line">docker exec -ti id 启动一个伪终端以交互式的方式进入某个容器（使用exit退出后容器不停止运行）</span><br><span class="line">docker images 查看本地镜像</span><br><span class="line">docker rm id&#x2F;name 删除某个容器</span><br><span class="line">docker rmi id&#x2F;name 删除某个镜像</span><br><span class="line">docker run --name test -ti ubuntu &#x2F;bin&#x2F;bash  复制ubuntu容器并且重命名为test且运行，然后以伪终端交互式方式进入容器，运行bash</span><br><span class="line">docker build -t soar&#x2F;centos:7.1 .  通过当前目录下的Dockerfile创建一个名为soar&#x2F;centos:7.1的镜像</span><br><span class="line">docker run -d -p 2222:22 --name test soar&#x2F;centos:7.1  以镜像soar&#x2F;centos:7.1创建名为test的容器，并以后台模式运行，并做端口映射到宿主机2222端口，P参数重启容器宿主机端口会发生改变</span><br><span class="line">https:&#x2F;&#x2F;registry.ihdou.com&#x2F;v2&#x2F;_catalog #查看仓库镜像</span><br></pre></td></tr></table></figure><h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</span><br><span class="line"></span><br><span class="line">image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 tomcat 服务器，形成你的 image。</span><br><span class="line"></span><br><span class="line">image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。</span><br><span class="line"></span><br><span class="line">为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 Docker Hub 是最重要、最常用的 image 仓库。此外，出售自己制作的 image 文件也是可以的。</span><br><span class="line">镜像是什么？</span><br><span class="line">一个分层存储的文件</span><br><span class="line">一个软件的环境</span><br><span class="line">一个镜像可以创建N个容器</span><br><span class="line">一个标准化的交付</span><br><span class="line">一个不包含Linux内核而又精简的Linux操作系统</span><br><span class="line">人性化一点 ↓</span><br><span class="line">docker镜像不包含Linux内核而又精简的Linux操作系统</span><br><span class="line"></span><br><span class="line">docker镜像是一个分层存储的文件，一个镜像可以创建N个容器</span><br><span class="line"></span><br><span class="line">可以这么理解，docker 镜像是 docker 容器的静态视角，docker 容器是 docker 镜像的运行状态。</span><br><span class="line"></span><br><span class="line">容器只是对docker镜像的引用，如果docker镜像删除，此镜像创建的容器也都失效</span><br><span class="line"></span><br><span class="line">镜像不是一个单一的文件，而是有多层结构。我们可以通过 docker history &lt;ID&#x2F;NAME&gt; 查看镜像中各层内容及大小，每层对应着DOckerfile 中的一条命令。Docker镜像默认存储在 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;&lt;storage-driver&gt;中。</span><br></pre></td></tr></table></figure><h3 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Hello world</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">run ubuntu:15.10 /bin/echo &quot;Hello world&quot;</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">run -i -t ubuntu:15.10 /bin/bash</span></span><br><span class="line"><span class="meta">以通过运行</span> <span class="string">exit 命令或者使用 CTRL+D 来退出容器</span></span><br><span class="line"><span class="attr">状态有7种：</span></span><br><span class="line"><span class="attr">created（已创建）</span></span><br><span class="line"><span class="attr">restarting（重启中）</span></span><br><span class="line"><span class="attr">running</span> <span class="string">或 Up（运行中）</span></span><br><span class="line"><span class="attr">removing（迁移中）</span></span><br><span class="line"><span class="attr">paused（暂停）</span></span><br><span class="line"><span class="attr">exited（停止）</span></span><br><span class="line"><span class="attr">dead（死亡）</span></span><br><span class="line"></span><br><span class="line"><span class="attr">docker</span> <span class="string">logs id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#小工具</span></span><br><span class="line"><span class="attr">https</span>:<span class="string">//github.com/oh-my-docker/net-box</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#docker方式运行一个tomcat应用</span></span><br><span class="line"><span class="attr">https</span>:<span class="string">//github.com/lizhenliang/tomcat-java-demo</span></span><br><span class="line"><span class="attr">mvn</span> <span class="string">clean package  -DskipTests=true</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">pull registry.ihdou.com/tomcat</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">build -t harry82/tomcat:v2 .</span></span><br><span class="line"><span class="attr">https</span>:<span class="string">//hub.docker.com/  harry82/1234Qwer@</span></span><br><span class="line"></span><br><span class="line"><span class="attr">docker</span> <span class="string">push harry82/tomcat:v2</span></span><br><span class="line"></span><br><span class="line"><span class="attr">docker</span> <span class="string">run -it --rm -p 8888:8080 -v $PWD/webapps:/usr/local/tomcat/webapps tomcat:8.0</span></span><br><span class="line"><span class="comment"># -it  是-i和 -t的简写， 表示以交互式的方式运行容器，加上-d表示后台运行，这里为了截图输出启动日志我用了-it，也可以用-d，再用&quot;docker logs 容器名&quot;命令输出日志</span></span><br><span class="line"><span class="comment"># --rm 当容器被停止时自动删除容器</span></span><br><span class="line"><span class="comment"># -p 8888:8080，8080是为容器中的tomcat设置的端口， 这里表示将8080映射到宿主机8888端口，如果只写-p 8080容器会随机取值32768~61000中较大的端口号来映射到80端口上</span></span><br><span class="line"><span class="comment"># -v 将tomcat中的usr/local/tomcat/webapps目录映射到宿主机当前目录的webapps目录，后面更新jar包直接扔到被映射的宿主机目录中即可</span></span><br><span class="line"><span class="comment"># tomcat:8.0  # 镜像名：tag标签</span></span><br><span class="line"></span><br><span class="line"><span class="attr">docker</span> <span class="string">run -it --rm -p 8888:8080  harry82/tomcat:v2</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">FROM</span> <span class="string">registry.ihdou.com/java8</span></span><br><span class="line"><span class="attr">LABEL</span> <span class="string">maintainer www.ihdou.cn</span></span><br><span class="line"><span class="attr">ADD</span> <span class="string">app-0.0.1-SNAPSHOT.jar app.jar</span></span><br><span class="line"><span class="attr">EXPOSE</span> <span class="string">8761</span></span><br><span class="line"><span class="attr">ENTRYPOINT</span> <span class="string">[&quot;java&quot;,&quot;-jar&quot;,&quot;app.jar&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">1</span> <span class="string">FROM: 基础镜像,通过jdk8镜像开始</span></span><br><span class="line"><span class="attr">2</span> <span class="string">MAINTAINER: 维护者</span></span><br><span class="line"><span class="attr">3</span> <span class="string">ADD: 复制jar包到镜像内,名字为app.jar</span></span><br><span class="line"><span class="attr">4</span> <span class="string">EXPOSE: 声明端口</span></span><br><span class="line"><span class="attr">5</span> <span class="string">ENTRYPOINT: docker启动时,运行的命令.这里就是容器运行就启动jar服务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#docker run -d --net=host  image:tag</span></span><br></pre></td></tr></table></figure><h4 id="重置docker网络"><a href="#重置docker网络" class="headerlink" title="重置docker网络"></a>重置docker网络</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#停止docker</span><br><span class="line">systemctl stop docker</span><br><span class="line">#docker0</span><br><span class="line">ip link set dev docker0 down</span><br><span class="line">#删除docker0网桥</span><br><span class="line">brctl delbr docker0</span><br><span class="line">#增加docker0 网桥</span><br><span class="line">brctl addbr docker0</span><br><span class="line">#增加网卡</span><br><span class="line">ip addr add 172.16.10.1&#x2F;24 dev docker0</span><br><span class="line">#启用网卡</span><br><span class="line">ip link set dev docker0 up</span><br><span class="line">#重启docker服务</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;docker是什么&quot;&gt;&lt;a href=&quot;#docker是什么&quot; class=&quot;headerlink&quot; title=&quot;docker是什么&quot;&gt;&lt;/a&gt;docker是什么&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Docker 到底是什么，要解决什么问题，好处又在哪里？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;虽然用户可以通过虚拟机还原软件的原始环境。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（1）资源占用多&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（2）冗余步骤多&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（3）启动慢&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（1）启动快&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（2）资源占用少&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（3）体积小&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Docker 的主要用途，目前有三大类。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（1）提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（2）提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（3）组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Docker 是一个开源的商业产品，有两个版本：社区版（Community Edition，缩写为 CE）和企业版（Enterprise Edition，缩写为 EE）。企业版包含了一些收费服务。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="ops" scheme="http://yoursite.com/categories/ops/"/>
    
    
    <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>expertor安装</title>
    <link href="http://yoursite.com/2020/10/28/exporter/"/>
    <id>http://yoursite.com/2020/10/28/exporter/</id>
    <published>2020-10-27T16:00:00.000Z</published>
    <updated>2020-10-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="node-exporter"><a href="#node-exporter" class="headerlink" title="node_exporter"></a>node_exporter</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">wget</span> <span class="string">https://github.com/prometheus/node_exporter/releases/download/v1.0.1/node_exporter-1.0.1.linux-amd64.tar.gz</span></span><br><span class="line"><span class="attr">tar</span> <span class="string">zxvf node_exporter-1.0.1.linux-amd64.tar.gz</span></span><br><span class="line"><span class="attr">mv</span> <span class="string">node_exporter-1.0.1.linux-amd64 node_exporter</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">vim</span> <span class="string">/etc/systemd/system/node_exporter.service </span></span><br><span class="line"><span class="attr">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=<span class="string">node_exporter</span></span><br><span class="line"><span class="attr">After</span>=<span class="string">network.target</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[Service]</span></span><br><span class="line"><span class="attr">Restart</span>=<span class="string">on-failure</span></span><br><span class="line"><span class="attr">ExecStart</span>=<span class="string">/opt/node_exporter/node_exporter</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=<span class="string">multi-user.target</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">systemctl</span> <span class="string">daemon-reload</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">enable node_exporter</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">start node_exporter</span></span><br></pre></td></tr></table></figure><h4 id="process-exporter"><a href="#process-exporter" class="headerlink" title="process_exporter"></a>process_exporter</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">wget</span> <span class="string">https://github.com/ncabatoff/process-exporter/releases/download/v0.7.2/process-exporter-0.7.2.linux-amd64.tar.gz</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">vim</span> <span class="string">/etc/systemd/system/process_exporter.service </span></span><br><span class="line"><span class="attr">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=<span class="string">process_exporter</span></span><br><span class="line"><span class="attr">Documentation</span>=<span class="string">https://prometheus.io/</span></span><br><span class="line"><span class="attr">After</span>=<span class="string">network.target</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=<span class="string">simple</span></span><br><span class="line"><span class="attr">User</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">ExecStart</span>=<span class="string">/data/process-exporter/process-exporter -config.path /data/process-exporter/process-name.yaml</span></span><br><span class="line"><span class="attr">Restart</span>=<span class="string">on-failure</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=<span class="string">multi-user.target</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">systemctl</span> <span class="string">daemon-reload</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">enable process_exporter</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">start process_exporter</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;node-exporter&quot;&gt;&lt;a href=&quot;#node-exporter&quot; class=&quot;headerlink&quot; title=&quot;node_exporter&quot;&gt;&lt;/a&gt;node_exporter&lt;/h4&gt;&lt;figure class=&quot;highlight prop</summary>
      
    
    
    
    <category term="ops" scheme="http://yoursite.com/categories/ops/"/>
    
    
    <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>kubeadm部署k8s集群</title>
    <link href="http://yoursite.com/2020/10/13/kubeadm%E9%83%A8%E7%BD%B2K8s%E9%9B%86%E7%BE%A4/"/>
    <id>http://yoursite.com/2020/10/13/kubeadm%E9%83%A8%E7%BD%B2K8s%E9%9B%86%E7%BE%A4/</id>
    <published>2020-10-13T03:00:00.000Z</published>
    <updated>2020-10-13T03:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>kubeadm是官方社区推出的一个用于快速部署kubernetes集群的工具。</p><p>这个工具能通过两条指令完成一个kubernetes集群的部署：</p><p>创建一个 Master 节点 kubeadm init</p><p>将一个 Node 节点加入到当前集群中 kubeadm join &lt;Master节点的IP和端口 &gt;</p><h4 id="安装要求"><a href="#安装要求" class="headerlink" title="安装要求"></a>安装要求</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">在开始之前，部署Kubernetes集群机器需要满足以下几个条件：</span></span><br><span class="line"><span class="meta">-</span>   <span class="string">一台或多台机器，操作系统 CentOS7.x-86_x64</span></span><br><span class="line"><span class="meta">-</span>   <span class="string">硬件配置：2GB或更多RAM，2个CPU或更多CPU，硬盘30GB或更多</span></span><br><span class="line"><span class="meta">-</span>   <span class="string">集群中所有机器之间网络互通</span></span><br><span class="line"><span class="meta">-</span>   <span class="string">可以访问外网，需要拉取镜像</span></span><br><span class="line"><span class="meta">-</span>   <span class="string">禁止swap分区</span></span><br></pre></td></tr></table></figure><h4 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-</span>   <span class="string">在所有节点上安装Docker和kubeadm</span></span><br><span class="line"><span class="meta">-</span>   <span class="string">部署Kubernetes Master</span></span><br><span class="line"><span class="meta">-</span>   <span class="string">部署容器网络插件</span></span><br><span class="line"><span class="meta">-</span>   <span class="string">部署 Kubernetes Node，将节点加入Kubernetes集群中</span></span><br><span class="line"><span class="meta">-</span>   <span class="string">部署Dashboard Web页面，可视化查看Kubernetes资源</span></span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="k8s-架构图"><a href="#k8s-架构图" class="headerlink" title="k8s 架构图"></a>k8s 架构图</h4><p><img src="https://raw.githubusercontent.com/hzq82/img/master/img/79f3493d9e783b3b74cdc8f1a3ef1b83.jpeg"></p><h4 id="基础环境-所有节点执行"><a href="#基础环境-所有节点执行" class="headerlink" title="基础环境(所有节点执行)"></a>基础环境(所有节点执行)</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">master</span> <span class="string">192.168.102.160</span></span><br><span class="line"><span class="attr">node1</span> <span class="string">192.168.102.161</span></span><br><span class="line"><span class="attr">node2</span> <span class="string">192.168.102.162</span></span><br><span class="line"><span class="comment">#1.关闭防火墙：</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">stop firewalld  systemctl disable firewalld</span></span><br><span class="line"><span class="comment">#2.关闭selinux：  </span></span><br><span class="line"><span class="attr">sed</span> <span class="string">-i &#x27;s/enforcing/disabled/&#x27; /etc/selinux/config #永久</span></span><br><span class="line"><span class="attr">setenforce</span> <span class="string">0  #临时</span></span><br><span class="line"><span class="comment">#3.关闭swap：</span></span><br><span class="line"><span class="attr">swapoff</span> <span class="string">-a #临时  vim /etc/fstab #永久</span></span><br><span class="line"><span class="comment">#4.设置主机名：</span></span><br><span class="line"><span class="attr">hostnamectl</span> <span class="string">set-hostname &lt;hostname&gt;</span></span><br><span class="line"><span class="comment">#在master添加hosts：</span></span><br><span class="line"><span class="attr">cat</span> <span class="string">&gt;&gt; /etc/hosts &lt;&lt;EOF</span></span><br><span class="line"><span class="meta">192.168.31.61</span> <span class="string">master </span></span><br><span class="line"><span class="meta">192.168.31.62</span> <span class="string">node1 </span></span><br><span class="line"><span class="meta">192.168.31.63</span> <span class="string">node2</span></span><br><span class="line"><span class="attr">EOF</span></span><br><span class="line"><span class="comment">#5.将桥接的IPv4流量传递到iptables的链：</span></span><br><span class="line"><span class="attr">cat</span> <span class="string">&gt; /etc/sysctl.d/k8s.conf &lt;&lt;EOF </span></span><br><span class="line"><span class="meta">net.bridge.bridge-nf-call-ip6tables</span> = <span class="string">1</span></span><br><span class="line"><span class="meta">net.bridge.bridge-nf-call-iptables</span> =<span class="string">1</span></span><br><span class="line"><span class="attr">EOF</span></span><br><span class="line"><span class="meta">$</span> <span class="string">sysctl --system #生效</span></span><br><span class="line"><span class="comment">#6.时间同步:</span></span><br><span class="line"><span class="attr">yum</span> <span class="string">install ntpdate -y </span></span><br><span class="line"><span class="attr">ntpdate</span> <span class="string">time.windows.com</span></span><br><span class="line"><span class="comment">#7时间同步</span></span><br><span class="line"><span class="attr">yum</span> <span class="string">install chrony -y</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">enable chronyd</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">start chronyd</span></span><br><span class="line"><span class="attr">chronyc</span> <span class="string">sources</span></span><br></pre></td></tr></table></figure><h4 id="安装docker-kubeadm-kubelet和kubectl-所有节点执行"><a href="#安装docker-kubeadm-kubelet和kubectl-所有节点执行" class="headerlink" title="安装docker,kubeadm,kubelet和kubectl(所有节点执行)"></a>安装docker,kubeadm,kubelet和kubectl(所有节点执行)</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装docker</span></span><br><span class="line"><span class="meta">[root@master</span> <span class="string">~]#wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo</span></span><br><span class="line"><span class="meta">[root@master</span> <span class="string">~]#yum -y install docker-ce-18.06.1.ce-3.el7</span></span><br><span class="line"><span class="meta">[root@master</span> <span class="string">~]#systemctl enable docker &amp;&amp; systemctl start docker</span></span><br><span class="line"><span class="meta">[root@master</span> <span class="string">~]# docker version</span></span><br><span class="line"><span class="attr">Client</span>:<span class="string"></span></span><br><span class="line"> <span class="attr">Version</span>:           <span class="string">18.06.1-ce</span></span><br><span class="line"><span class="comment">#修改docker下载镜像的默认源</span></span><br><span class="line"><span class="meta">[root@master</span> <span class="string">~]#cat &gt; /etc/docker/daemon.json &lt;&lt; EOF</span></span><br><span class="line"> <span class="meta">&#123;</span> <span class="string">&quot;registry-mirrors&quot;:</span></span><br><span class="line"><span class="meta">[&quot;https</span>:<span class="string">//b9pmyelo.mirror.aliyuncs.com&quot;] &#125;</span></span><br><span class="line"><span class="attr">EOF</span></span><br><span class="line"><span class="comment">#添加阿里云k8s镜像源</span></span><br><span class="line"><span class="meta">[root@master</span> <span class="string">~]#cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF </span></span><br><span class="line"><span class="meta">[kubernetes]</span> <span class="string"></span></span><br><span class="line"><span class="attr">name</span>=<span class="string">Kubernetes</span></span><br><span class="line"><span class="attr">baseurl</span>=<span class="string">https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span></span><br><span class="line"><span class="attr">enabled</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="string">0</span></span><br><span class="line"><span class="attr">repo_gpgcheck</span>=<span class="string">0</span></span><br><span class="line"><span class="attr">gpgkey</span>=<span class="string">https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span></span><br><span class="line"><span class="attr">https</span>:<span class="string">//mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg </span></span><br><span class="line"><span class="attr">EOF</span></span><br><span class="line"><span class="comment">#安装kubeadm，kubelet和kubectl</span></span><br><span class="line"><span class="meta">[root@master</span> <span class="string">~]#yum install -y kubelet-1.18.0 kubeadm-1.18.0 kubectl-1.18.0</span></span><br><span class="line"><span class="meta">[root@master</span> <span class="string">~]#systemctl enable kubelet</span></span><br></pre></td></tr></table></figure><h4 id="部署Kubernetes-Master"><a href="#部署Kubernetes-Master" class="headerlink" title="部署Kubernetes Master"></a>部署Kubernetes Master</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在master执行，由于默认拉取镜像地址k8s.gcr.io国内无法访问，这里指定阿里云镜像仓库地址。</span></span><br><span class="line"><span class="meta">[root@master</span> <span class="string">~]#kubeadm init \</span></span><br><span class="line"><span class="meta">--apiserver-advertise-address</span>=<span class="string">192.168.102.160  \</span></span><br><span class="line"><span class="meta">--image-repository</span> <span class="string">registry.aliyuncs.com/google_containers  \</span></span><br><span class="line"><span class="meta">--kubernetes-version</span> <span class="string">v1.18.0 \</span></span><br><span class="line"><span class="meta">--service-cidr</span>=<span class="string">10.96.0.0/12 \</span></span><br><span class="line"><span class="meta">--pod-network-cidr</span>=<span class="string">10.244.0.0/16</span></span><br><span class="line"><span class="comment">#使用kubectl工具（为了能使用kubectl连接集群，执行下面提示的命令）：</span></span><br><span class="line">  <span class="attr">mkdir</span> <span class="string">-p $HOME/.kube</span></span><br><span class="line">  <span class="attr">sudo</span> <span class="string">cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span></span><br><span class="line">  <span class="attr">sudo</span> <span class="string">chown $(id -u):$(id -g) $HOME/.kube/config</span></span><br><span class="line"><span class="attr">kubectl</span> <span class="string">get nodes （此时发现master 状态为 noready）</span></span><br><span class="line"><span class="comment">#此时master为准备就绪，需要完成下面步骤 (安装Pod网络插件（CNI）)\</span></span><br><span class="line"><span class="attr">vi</span> <span class="string">/etc/hosts #添加</span></span><br><span class="line"><span class="meta">199.232.28.133</span> <span class="string">gist.githubusecontent.com</span></span><br><span class="line"><span class="meta">199.232.28.133</span> <span class="string">user-images.githubusercontent.com</span></span><br><span class="line"><span class="meta">199.232.28.133</span> <span class="string">raw.githubusercontent.com</span></span><br><span class="line"><span class="meta">199.232.28.133</span> <span class="string">camo.githubusercontent.com</span></span><br><span class="line"><span class="meta">199.232.28.133</span> <span class="string">cloud.githubusercontent.com</span></span><br><span class="line"><span class="meta">199.232.28.133</span> <span class="string">avatars0.githubusercontent.com</span></span><br><span class="line"><span class="meta">199.232.28.133</span> <span class="string">avatars1.githubusercontent.com</span></span><br><span class="line"><span class="meta">199.232.28.133</span> <span class="string">avatars2.githubusercontent.com</span></span><br><span class="line"><span class="meta">199.232.28.133</span> <span class="string">avatars3.githubusercontent.com</span></span><br><span class="line"><span class="meta">199.232.28.133</span> <span class="string">avatars4.githubusercontent.com</span></span><br><span class="line"><span class="meta">199.232.28.133</span> <span class="string">avatars5.githubusercontent.com</span></span><br><span class="line"><span class="meta">199.232.28.133</span> <span class="string">avatars6.githubusercontent.com</span></span><br><span class="line"><span class="meta">199.232.28.133</span> <span class="string">avatars7.githubusercontent.com</span></span><br><span class="line"><span class="meta">199.232.28.133</span> <span class="string">avatars8.githubusercontent.com</span></span><br><span class="line"></span><br><span class="line"><span class="meta">[root@master</span> <span class="string">~]#wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span></span><br><span class="line"><span class="meta">[root@master</span> <span class="string">~]#kubectl apply -f kube-flannel.yml</span></span><br><span class="line"><span class="meta">[root@master</span> <span class="string">~]#kubectl get pods -n kube-system</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#加入Kubernetes Node</span></span><br><span class="line"><span class="meta">在node节点上执行，向集群添加新节点，执行在kubeadm</span> <span class="string">init输出的kubeadm join命令：</span></span><br><span class="line"><span class="attr">kubeadm</span> <span class="string">join 192.168.102.160:6443 --token yltp22.fs62engd2ekxgxos \</span></span><br><span class="line">    <span class="meta">--discovery-token-ca-cert-hash</span> <span class="string">sha256:3ca566c556064fce9aaa2daa618f78066df9978a12b9419a1fc0db595b1c021d </span></span><br><span class="line"><span class="comment">#默认token有效期为24小时，当过期之后，该token就不可用了。这时就需要重新创建token，操作如下：</span></span><br><span class="line"><span class="meta">$</span> <span class="string">kubeadm token create --print-join-command</span></span><br><span class="line"><span class="comment">#测试kubernetes集群，在Kubernetes集群中创建一个pod，验证是否正常运行：</span></span><br><span class="line"><span class="meta">$</span> <span class="string">kubectl create deployment nginx --image=nginx </span></span><br><span class="line"><span class="meta">$</span> <span class="string">kubectl expose deployment nginx --port=80 --type=NodePort </span></span><br><span class="line"><span class="meta">$</span> <span class="string">kubectl get pod,svc</span></span><br><span class="line"><span class="meta">访问地址：http</span>:<span class="string">//NodeIP:Port</span></span><br></pre></td></tr></table></figure><h4 id="部署-Dashboard"><a href="#部署-Dashboard" class="headerlink" title="部署 Dashboard"></a>部署 Dashboard</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kubectl</span> <span class="string">apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta8/aio/deploy/recommended.yaml</span></span><br><span class="line"><span class="meta">修改</span> <span class="string">recommended.yaml</span></span><br><span class="line"><span class="attr">spec</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">type</span>: <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">-</span> <span class="string">port: 443</span></span><br><span class="line">      <span class="attr">targetPort</span>: <span class="string">8443</span></span><br><span class="line">      <span class="attr">nodePort</span>: <span class="string">30001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">kubectl</span> <span class="string">apply -f recommended.yaml</span></span><br><span class="line"><span class="meta">访问地址：http</span>:<span class="string">//NodeIP:30001</span></span><br><span class="line"><span class="comment">#创建service account并绑定默认cluster-admin管理员集群角色：</span></span><br><span class="line"><span class="meta">创建用户</span>:<span class="string">kubectl create serviceaccount dashboard-admin -n kube-system</span></span><br><span class="line"><span class="meta">用户授权</span>:<span class="string">kubectl create clusterrolebinding dashboard-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-admin</span></span><br><span class="line"><span class="meta">获取用户Token</span>:<span class="string">kubectl describe secrets -n kube-system $(kubectl -n kube-system get secret | awk &#x27;/dashboard-admin/&#123;print $1&#125;&#x27;)</span></span><br><span class="line"><span class="comment">#使用输出的token登录Dashboard</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="集群测试"><a href="#集群测试" class="headerlink" title="集群测试"></a>集群测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl create deployment nginx --image&#x3D;nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/ad27168bebb5">https://www.jianshu.com/p/ad27168bebb5</a> #安装calico网络</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;kubeadm是官方社区推出的一个用于快速部署kubernetes集群的工具。&lt;/p&gt;
&lt;p&gt;这个工具能通过两条指令完成一个kubernetes集群的部署：&lt;/p&gt;
&lt;p&gt;创建一个 Master 节点 kubeadm init&lt;/p&gt;
&lt;p&gt;将一个 Node 节点加入到当前集群中 kubeadm join &amp;lt;Master节点的IP和端口 &amp;gt;&lt;/p&gt;
&lt;h4 id=&quot;安装要求&quot;&gt;&lt;a href=&quot;#安装要求&quot; class=&quot;headerlink&quot; title=&quot;安装要求&quot;&gt;&lt;/a&gt;安装要求&lt;/h4&gt;&lt;figure class=&quot;highlight properties&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;在开始之前，部署Kubernetes集群机器需要满足以下几个条件：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;-&lt;/span&gt;   &lt;span class=&quot;string&quot;&gt;一台或多台机器，操作系统 CentOS7.x-86_x64&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;-&lt;/span&gt;   &lt;span class=&quot;string&quot;&gt;硬件配置：2GB或更多RAM，2个CPU或更多CPU，硬盘30GB或更多&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;-&lt;/span&gt;   &lt;span class=&quot;string&quot;&gt;集群中所有机器之间网络互通&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;-&lt;/span&gt;   &lt;span class=&quot;string&quot;&gt;可以访问外网，需要拉取镜像&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;-&lt;/span&gt;   &lt;span class=&quot;string&quot;&gt;禁止swap分区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;学习目标&quot;&gt;&lt;a href=&quot;#学习目标&quot; class=&quot;headerlink&quot; title=&quot;学习目标&quot;&gt;&lt;/a&gt;学习目标&lt;/h4&gt;&lt;figure class=&quot;highlight properties&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;-&lt;/span&gt;   &lt;span class=&quot;string&quot;&gt;在所有节点上安装Docker和kubeadm&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;-&lt;/span&gt;   &lt;span class=&quot;string&quot;&gt;部署Kubernetes Master&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;-&lt;/span&gt;   &lt;span class=&quot;string&quot;&gt;部署容器网络插件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;-&lt;/span&gt;   &lt;span class=&quot;string&quot;&gt;部署 Kubernetes Node，将节点加入Kubernetes集群中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;-&lt;/span&gt;   &lt;span class=&quot;string&quot;&gt;部署Dashboard Web页面，可视化查看Kubernetes资源&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="ops" scheme="http://yoursite.com/categories/ops/"/>
    
    
    <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>centos shadowsocks</title>
    <link href="http://yoursite.com/2020/09/11/cenos7%20shadowsocks/"/>
    <id>http://yoursite.com/2020/09/11/cenos7%20shadowsocks/</id>
    <published>2020-09-10T16:00:00.000Z</published>
    <updated>2020-09-10T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-安装配置Shadowsocks客户端"><a href="#1-安装配置Shadowsocks客户端" class="headerlink" title="1. 安装配置Shadowsocks客户端"></a>1. 安装配置Shadowsocks客户端</h2><h3 id="1-1-安装Shadowsocks客户端"><a href="#1-1-安装Shadowsocks客户端" class="headerlink" title="1.1 安装Shadowsocks客户端"></a>1.1 安装Shadowsocks客户端</h3><ul><li>安装epel扩展源<br> 采用Python包管理工pip安装。</li></ul><ol><li><code>yum -y install epel-release</code></li><li><code>yum -y install python-pip</code></li></ol><ul><li>安装Shadowsocks客户端</li></ul><ol><li><p><code>pip install shadowsocks</code></p><a id="more"></a></li></ol><h3 id="1-2-配置Shadowsocks客户端"><a href="#1-2-配置Shadowsocks客户端" class="headerlink" title="1.2 配置Shadowsocks客户端"></a>1.2 配置Shadowsocks客户端</h3><ul><li>新建配置文件</li></ul><ol><li><code>mkdir /etc/shadowsocks</code></li><li><code>vi /etc/shadowsocks/shadowsocks.json</code></li></ol><ul><li>添加配置信息</li></ul><ol><li><code>&#123;</code></li><li><code>&quot;server&quot;:&quot;1.1.1.1&quot;,</code></li><li><code>&quot;server_port&quot;:1035,</code></li><li><code>&quot;local_address&quot;:  &quot;127.0.0.1&quot;,</code></li><li><code>&quot;local_port&quot;:1080,</code></li><li><code>&quot;password&quot;:&quot;password&quot;,</code></li><li><code>&quot;timeout&quot;:300,</code></li><li><code>&quot;method&quot;:&quot;aes-256-cfb&quot;,</code></li><li><code>&quot;fast_open&quot;:  false,</code></li><li><code>&quot;workers&quot;:  1</code></li><li><code>&#125;</code></li></ol><p>参数说明：<br> server：Shadowsocks服务器地址<br> server_port：Shadowsocks服务器端口<br> local_address：本地IP<br> local_port：本地端口<br> password：Shadowsocks连接密码<br> timeout：等待超时时间<br> method：加密方式<br> workers:工作线程数<br> fast_open：true或false。开启fast_open以降低延迟，但要求Linux内核在3.7+。开启方法 <code>echo 3 &gt; /proc/sys/net/ipv4/tcp_fastopen</code></p><ul><li>配置自启动<br> ① 新建启动脚本文件/etc/systemd/system/shadowsocks.service，内容如下：</li></ul><ol><li><code>[Unit]</code></li><li><code>Description=Shadowsocks</code></li><li><code>[Service]</code></li><li><code>TimeoutStartSec=0</code></li><li><code>ExecStart=/usr/bin/sslocal -c /etc/shadowsocks/shadowsocks.json</code></li><li><code>[Install]</code></li><li><code>WantedBy=multi-user.target</code></li></ol><p>② 启动Shadowsocks客户端</p><ol><li><code>systemctl enable shadowsocks.service</code></li><li><code>systemctl start shadowsocks.service</code></li><li><code>systemctl status shadowsocks.service</code></li></ol><ul><li>验证Shadowsocks客户端是否正常运行</li></ul><ol><li><code>curl --socks5 127.0.0.1:1080 http://httpbin.org/ip</code></li></ol><p>若Shadowsock客户端已正常运行，则结果如下：</p><ol><li><code>&#123;</code></li><li><code>&quot;origin&quot;:  &quot;x.x.x.x&quot;  #你的Shadowsock服务器IP</code></li><li><code>&#125;</code></li></ol><h2 id="2-安装配置Privoxy"><a href="#2-安装配置Privoxy" class="headerlink" title="2. 安装配置Privoxy"></a>2. 安装配置Privoxy</h2><p>Shadowsocks是一个 socket5 服务，我们需要使用 Privoxy 把流量转到 http／https 上。</p><h3 id="2-1-安装Privoxy"><a href="#2-1-安装Privoxy" class="headerlink" title="2.1 安装Privoxy"></a>2.1 安装Privoxy</h3><ul><li>安装Privoxy</li></ul><ol><li><code>yum -y install privoxy</code></li></ol><ul><li>启动Privoxy</li></ul><ol><li><code>systemctl enable privoxy</code></li><li><code>systemctl start privoxy</code></li><li><code>systemctl status privoxy</code></li></ol><h3 id="2-2-配置Privoxy"><a href="#2-2-配置Privoxy" class="headerlink" title="2.2 配置Privoxy"></a>2.2 配置Privoxy</h3><ul><li>配置Privoxy<br> ① 修改配置文件/etc/privoxy/config</li></ul><ol><li><code>vi /etc/privoxy/config</code></li></ol><p>② 确保如下内容没有被注释掉</p><ol><li><code>listen-address 127.0.0.1:8118  # 8118 是默认端口，不用改</code></li><li><code>forward-socks5t /  127.0.0.1:1080  .  #转发到本地端口</code></li></ol><ul><li>设置http/https代理<br> ① 修改配置文件/etc/profile</li></ul><ol><li><code>sudo vi /etc/profile</code></li></ol><p>添加如下信息：</p><ol><li><p><code>export http_proxy=http://127.0.0.1:8118</code></p></li><li><p><code>export https_proxy=http://127.0.0.1:8118</code></p></li><li><p><code>source /etc/profile</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#另一种方式</span><br><span class="line">cat &#x2F;etc&#x2F;profile</span><br><span class="line"></span><br><span class="line">PROXY_HOST&#x3D;127.0.0.1</span><br><span class="line">export all_proxy&#x3D;http:&#x2F;&#x2F;$PROXY_HOST:8118</span><br><span class="line">export ftp_proxy&#x3D;http:&#x2F;&#x2F;$PROXY_HOST:8118</span><br><span class="line">export http_proxy&#x3D;http:&#x2F;&#x2F;$PROXY_HOST:8118</span><br><span class="line">export https_proxy&#x3D;http:&#x2F;&#x2F;$PROXY_HOST:8118</span><br><span class="line">export no_proxy&#x3D;localhost,172.16.0.0&#x2F;16,192.168.0.0&#x2F;16.,127.0.0.1,10.10.0.0&#x2F;16</span><br></pre></td></tr></table></figure></li></ol><p><strong>注：</strong>端口和privoxy 中的监听端口保持一致</p><ul><li>验证是否可用</li></ul><ol><li><code>curl -SL www.google.com</code></li></ol><p><code> #参考 https://hongyuanyu.github.io/2019/04/24/centos配置shadowsocks客户端/</code></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-安装配置Shadowsocks客户端&quot;&gt;&lt;a href=&quot;#1-安装配置Shadowsocks客户端&quot; class=&quot;headerlink&quot; title=&quot;1. 安装配置Shadowsocks客户端&quot;&gt;&lt;/a&gt;1. 安装配置Shadowsocks客户端&lt;/h2&gt;&lt;h3 id=&quot;1-1-安装Shadowsocks客户端&quot;&gt;&lt;a href=&quot;#1-1-安装Shadowsocks客户端&quot; class=&quot;headerlink&quot; title=&quot;1.1 安装Shadowsocks客户端&quot;&gt;&lt;/a&gt;1.1 安装Shadowsocks客户端&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;安装epel扩展源&lt;br&gt; 采用Python包管理工pip安装。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;yum -y install epel-release&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;yum -y install python-pip&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;安装Shadowsocks客户端&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;pip install shadowsocks&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ops" scheme="http://yoursite.com/categories/ops/"/>
    
    
    <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>istio</title>
    <link href="http://yoursite.com/2020/09/09/istio/"/>
    <id>http://yoursite.com/2020/09/09/istio/</id>
    <published>2020-09-08T16:00:00.000Z</published>
    <updated>2020-09-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="kubernetes"><a href="#kubernetes" class="headerlink" title="kubernetes"></a>kubernetes</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubernetes 提供平台基础设施层强大的容器编排和调度能力；</span><br><span class="line">--服务部署与弹性伸缩：Deployment</span><br><span class="line">--服务拆分和服务发现：Services</span><br><span class="line">kubernetes 提供简单的负载均衡能力</span><br><span class="line">--负载均衡：基于IPVS（IP Virtual Server）及iptables的简单均衡机制</span><br></pre></td></tr></table></figure><h4 id="istio-是什么"><a href="#istio-是什么" class="headerlink" title="istio 是什么"></a>istio 是什么</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    服务网格词汇 Istio，希腊语言中大概是风帆的意思， 发音  [iːst&#39;iəʊ] ，相当于中文的 伊斯特亿欧</span><br><span class="line">    Istio 是由 Google、IBM、Lyft 等共同开源的 Service Mesh（服务网格）框架，于2017年初开始进入大众视野。</span><br><span class="line">    Istio 允许您连接、保护、控制和观察服务。</span><br><span class="line">从较高的层面来说，Istio 有助于降低这些部署的复杂性，并减轻开发团队的压力。它是一个完全开源的服务网格，作为透明的一层接入到现有的分布式应用程序里。它也是一个平台，拥有可以集成任何日志、遥测和策略系统的 API 接口。Istio 多样化的特性使您能够成功且高效地运行分布式微服务架构，并提供保护、连接和监控微服务的统一方法。</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="https://raw.githubusercontent.com/hzq82/img/master/img/istio.jpg"></p><h4 id="服务网格是什么-Service-Mesh"><a href="#服务网格是什么-Service-Mesh" class="headerlink" title="服务网格是什么(Service Mesh)"></a>服务网格是什么(Service Mesh)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   服务网格用来描述组成这些应用程序的微服务网络以及它们之间的交互。随着服务网格的规模和复杂性不断的增长，它将会变得越来越难以理解和管理。它的需求包括服务发现、负载均衡、故障恢复、度量和监控等。服务网格通常还有更复杂的运维需求，比如 A&#x2F;B 测试、金丝雀发布、速率限制、访问控制和端到端认证。</span><br><span class="line">   服务网格（Service Mesh）是处理服务间通信的基础设施层。它负责构成现代云原生应用程序的复杂服务拓扑来可靠地交付请求。在实践中，Service Mesh 通常以轻量级网络代理阵列的形式实现，这些代理与应用程序代码部署在一起，对应用程序来说无需感知代理的存在。</span><br><span class="line"></span><br><span class="line">Service Mesh 有如下几个特点：</span><br><span class="line">应用程序间通信的中间层</span><br><span class="line">轻量级网络代理</span><br><span class="line">应用程序无感知</span><br><span class="line">解耦应用程序的重试&#x2F;超时、监控、追踪和服务发现</span><br><span class="line">目前两款流行的 Service Mesh 开源软件 Istio 和 Linkerd 都可以直接在 Kubernetes 中集成。</span><br></pre></td></tr></table></figure><h4 id="回顾一下网络代理"><a href="#回顾一下网络代理" class="headerlink" title="回顾一下网络代理"></a>回顾一下网络代理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">说起网络代理，我们会想到翻墙，如果对软件架构比较熟悉的会想到 Nginx 等反向代理软件。</span><br><span class="line">其实网络代理的范围比较广，可以肯定的说，有网络访问的地方就会有代理的存在。</span><br><span class="line">NOTE：代理可以是嵌套的，也就是说通信双方 A、B 中间可以多多层代理，而这些代理的存在有可能对 A、B 是透明的。</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/hzq82/img/master/img/porxy.jpg"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Service Mesh 可以看做是传统代理的升级版，用来解决现在微服务框架中出现的问题，可以把 Service Mesh 看做是分布式的微服务代理。</span><br><span class="line">在传统模式下，代理一般是集中式的单独的服务器，所有的请求都要先通过代理，然后再流入转发到实际的后端。</span><br><span class="line">而在 Service Mesh 中，代理变成了分布式的，它常驻在了应用的身边（最常见的就是 Kubernetes Sidecar 模式，每一个应用的 Pod 中都运行着一个代理，负责流量相关的事情）。</span><br><span class="line">这样的话，应用所有的流量都被代理接管，那么这个代理就能做到上面提到的所有可能的事情，从而带来无限的想象力。</span><br></pre></td></tr></table></figure><h4 id="理解Service-Mesh"><a href="#理解Service-Mesh" class="headerlink" title="理解Service Mesh"></a>理解Service Mesh</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果用一句话来解释什么是 Service Mesh，可以将它比作是应用程序或者说微服务间的 TCP&#x2F;IP，负责服务之间的网络调用、限流、熔断和监控。对于编写应用程序来说一般无须关心 TCP&#x2F;IP 这一层（比如通过 HTTP 协议的 RESTful 应用），同样使用 Service Mesh 也就无须关心服务之间的那些原本通过服务框架实现的事情，比如 Spring Cloud、Netflix OSS 和其他中间件，现在只要交给 Service Mesh 就可以了。</span><br></pre></td></tr></table></figure><h4 id="Sidecar概念"><a href="#Sidecar概念" class="headerlink" title="Sidecar概念"></a>Sidecar概念</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    Sidecar模式是一种将应用功能从应用本身剥离出来作为单独进程的方式。该模式允许我们向应用无侵入添加多种功能，避免了为满足第三方组件需求而向应用添加额外的配置代码。</span><br><span class="line">就像边车加装在摩托车上一样，在软件架构中，sidecar附加到主应用，或者叫父应用上，以扩展&#x2F;增强功能特性，同时Sidecar与主应用是松耦合的。</span><br><span class="line">举个例子，假设现在有6个相互通信的微服务，每个微服务都需要具有可观察性、监控、日志记录、配置、断路器等功能，而所有这些功能都是在微服务中使用一些第三方库实现的。这样一组服务的实际情况可能会非常复杂，增加了应用的整体复杂性，尤其是当每个微服务用不同的语言编写。</span><br></pre></td></tr></table></figure><p>Service Mesh 的架构如下图所示:</p><p><img src="https://raw.githubusercontent.com/hzq82/img/master/img/service-mesh-arch.png"></p><p>Service Mesh 作为 sidecar 运行，对应用程序来说是透明，所有应用程序间的流量都会通过它，所以对应用程序流量的控制都可以在 serivce mesh 中实现。</p><p><img src="https://raw.githubusercontent.com/hzq82/img/master/img/service-mesh-1.png"></p><p>​      其中绿色方块为应用服务，蓝色方块为 Sidecar Proxy，应用服务之间通过 Sidecar Proxy 进行通信，整个服务通信形成图中的蓝色网络连线，图中所有蓝色部分就形成了 Service Mesh。</p><p>​      我们会看到上面的服务不再负责传递请求的具体逻辑，只负责完成业务处理。服务间通讯的环节就从应用里面剥离出来，呈现出一个抽象层。有大量服务，表现为网络。</p><h4 id="kubernetes-和Istio-的关系"><a href="#kubernetes-和Istio-的关系" class="headerlink" title="kubernetes 和Istio 的关系"></a>kubernetes 和Istio 的关系</h4><p><img src="https://raw.githubusercontent.com/hzq82/img/master/img/istio-1.jpg"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">istios 完美补齐了k8s服务治理的能力，从功能上来讲istio和k8s是一种完美的结合。</span><br></pre></td></tr></table></figure><h4 id="istio-架构"><a href="#istio-架构" class="headerlink" title="istio 架构"></a>istio 架构</h4><p><img src="https://raw.githubusercontent.com/hzq82/img/master/img/istio-2.jpg"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Istio 服务网格从逻辑上分为数据平面和控制平面。</span><br><span class="line">数据平面 由一组智能代理（Envoy）组成，被部署为 sidecar。这些代理负责协调和控制微服务之间的所有网络通信。他们还收集和报告所有网格流量的遥测数据。</span><br><span class="line">控制平面 管理并配置代理来进行流量路由。</span><br><span class="line">Istio 中的流量分为数据平面流量和控制平面流量。数据平面流量是指工作负载的业务逻辑发送和接收的消息。控制平面流量是指在 Istio 组件之间发送的配置和控制消息用来编排网格的行为。Istio 中的流量管理特指数据平面流量。</span><br><span class="line">pilot  配置规则到proxy，用户自己定义的rule。</span><br><span class="line">mixer  执行访问控制和使用策略、遥测（Telemetry）,遥测的含义引申为对各种指标（metric）数据进行收集，并监控、分析这些指标</span><br><span class="line">citadel 安全管理中心，身份认证，证书的生成下发，</span><br><span class="line">galley  对规则进行verify data。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><img src="https://raw.githubusercontent.com/hzq82/img/master/img/istio-3.jpg"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   这个示例部署了一个用于演示多种 Istio 特性的应用，该应用由四个单独的微服务构成。 这个应用模仿在线书店的一个分类，显示一本书的信息。 页面上会显示一本书的描述，书籍的细节（ISBN、页数等），以及关于这本书的一些评论。</span><br><span class="line">Bookinfo 应用分为四个单独的微服务：</span><br><span class="line">productpage. 这个微服务会调用 details 和 reviews 两个微服务，用来生成页面。</span><br><span class="line">details. 这个微服务中包含了书籍的信息。</span><br><span class="line">reviews. 这个微服务中包含了书籍相关的评论。它还会调用 ratings 微服务。</span><br><span class="line">ratings. 这个微服务中包含了由书籍评价组成的评级信息。</span><br><span class="line">reviews 微服务有 3 个版本：</span><br><span class="line">v1 版本不会调用 ratings 服务。</span><br><span class="line">v2 版本会调用 ratings 服务，并使用 1 到 5 个黑色星形图标来显示评分信息。</span><br><span class="line">v3 版本会调用 ratings 服务，并使用 1 到 5 个红色星形图标来显示评分信息。</span><br><span class="line">   Bookinfo 应用中的几个微服务是由不同的语言编写的。 这些服务对 Istio 并无依赖，但是构成了一个有代表性的服务网格的例子：它由多个服务、多个语言构成，并且 reviews 服务具有多个版本。</span><br></pre></td></tr></table></figure><h4 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">curl</span> <span class="string">-L https://istio.io/downloadIstio | sh -</span></span><br><span class="line"><span class="attr">cd</span> <span class="string">istio-1.5.1</span></span><br><span class="line"><span class="attr">export</span> <span class="string">PATH=$PWD/bin:$PATH</span></span><br><span class="line"><span class="attr">istioctl</span> <span class="string">verify-install</span></span><br><span class="line"><span class="attr">istioctl</span> <span class="string">manifest apply --set profile=demo</span></span><br><span class="line"><span class="attr">kubectl</span> <span class="string">label namespace default istio-injection=enabled</span></span><br><span class="line"><span class="attr">kubectl</span> <span class="string">apply -f samples/bookinfo/platform/kube/bookinfo.yaml</span></span><br><span class="line"><span class="attr">kubectl</span> <span class="string">apply -f samples/bookinfo/networking/bookinfo-gateway.yaml</span></span><br><span class="line"><span class="attr">kubectl</span> <span class="string">apply -f destination-rule-all.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">kubectl</span> <span class="string">apply  -f virtual-service-reviews-v3.yaml</span></span><br></pre></td></tr></table></figure><h4 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f destination-rule-all.yaml</span><br><span class="line">kubectl apply  -f samples&#x2F;bookinfo&#x2F;networking&#x2F;virtual-service-reviews-v3.yaml</span><br><span class="line"></span><br><span class="line">watch -n 1 curl http:&#x2F;&#x2F;34.69.229.114&#x2F;productpage</span><br><span class="line"></span><br><span class="line">删除实例应用</span><br><span class="line">samples&#x2F;bookinfo&#x2F;platform&#x2F;kube&#x2F;cleanup.sh</span><br><span class="line"></span><br><span class="line">istioctl dashboard kiali</span><br><span class="line">watch -n 1 curl https:&#x2F;&#x2F;&#123;YOURDOMAIN&#125;&#x2F;productpage</span><br><span class="line"></span><br><span class="line">卸载 Istio</span><br><span class="line">istioctl manifest generate --set profile&#x3D;demo | kubectl delete -f -</span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;www.servicemesher.com&#x2F;blog&#x2F;istio-routing-basics&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;kubernetes&quot;&gt;&lt;a href=&quot;#kubernetes&quot; class=&quot;headerlink&quot; title=&quot;kubernetes&quot;&gt;&lt;/a&gt;kubernetes&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;kubernetes 提供平台基础设施层强大的容器编排和调度能力；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;--服务部署与弹性伸缩：Deployment&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;--服务拆分和服务发现：Services&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kubernetes 提供简单的负载均衡能力&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;--负载均衡：基于IPVS（IP Virtual Server）及iptables的简单均衡机制&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;istio-是什么&quot;&gt;&lt;a href=&quot;#istio-是什么&quot; class=&quot;headerlink&quot; title=&quot;istio 是什么&quot;&gt;&lt;/a&gt;istio 是什么&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    服务网格词汇 Istio，希腊语言中大概是风帆的意思， 发音  [iːst&amp;#39;iəʊ] ，相当于中文的 伊斯特亿欧&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Istio 是由 Google、IBM、Lyft 等共同开源的 Service Mesh（服务网格）框架，于2017年初开始进入大众视野。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Istio 允许您连接、保护、控制和观察服务。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;从较高的层面来说，Istio 有助于降低这些部署的复杂性，并减轻开发团队的压力。它是一个完全开源的服务网格，作为透明的一层接入到现有的分布式应用程序里。它也是一个平台，拥有可以集成任何日志、遥测和策略系统的 API 接口。Istio 多样化的特性使您能够成功且高效地运行分布式微服务架构，并提供保护、连接和监控微服务的统一方法。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="ops" scheme="http://yoursite.com/categories/ops/"/>
    
    
    <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>kubenetes 单机版</title>
    <link href="http://yoursite.com/2020/09/09/kubenetes%20%E5%8D%95%E6%9C%BA%E7%89%88/"/>
    <id>http://yoursite.com/2020/09/09/kubenetes%20%E5%8D%95%E6%9C%BA%E7%89%88/</id>
    <published>2020-09-08T16:00:00.000Z</published>
    <updated>2020-09-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="关闭centos-自带的防火墙服务"><a href="#关闭centos-自带的防火墙服务" class="headerlink" title="关闭centos 自带的防火墙服务"></a>关闭centos 自带的防火墙服务</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">systemctl</span> <span class="string">stop firewalld</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">disable firewalld</span></span><br></pre></td></tr></table></figure><h4 id="配置kubenetes-源"><a href="#配置kubenetes-源" class="headerlink" title="配置kubenetes 源"></a>配置kubenetes 源</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">vi</span> <span class="string">/etc/yum.repos.d/kubernetes.repo</span></span><br><span class="line"><span class="attr">[Kubernetes]</span></span><br><span class="line"><span class="attr">baseurl</span>=<span class="string">http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span></span><br><span class="line"><span class="attr">enabled</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="string">0</span></span><br><span class="line"><span class="attr">repo_gpgcheck</span>=<span class="string">0</span></span><br><span class="line"><span class="attr">gpgkey</span>=<span class="string">http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg  http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span></span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="安装etcd-kubernetes"><a href="#安装etcd-kubernetes" class="headerlink" title="安装etcd kubernetes"></a>安装etcd kubernetes</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#自动附带安装Docker</span></span><br><span class="line"><span class="attr">yum</span> <span class="string">install -y etcd kubernetes </span></span><br></pre></td></tr></table></figure><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改option的内容如下:</span></span><br><span class="line"><span class="attr">vi</span> <span class="string">/etc/sysconfig/docker</span></span><br><span class="line"><span class="attr">OPTIONS</span>=<span class="string">&#x27;--selinux-enabled=false --insecure-registry gcr.io&#x27;</span></span><br><span class="line"><span class="comment">#修改apiserver配置</span></span><br><span class="line"><span class="attr">vi</span> <span class="string">/etc/kubernetes/apiserver</span></span><br><span class="line"><span class="attr">KUBE_ADMISSION_CONTROL</span>=<span class="string">&quot;--admission-control=NamespaceLifecycle,NamespaceExists,LimitRanger,SecurityContextDeny,ResourceQuota&quot;</span></span><br></pre></td></tr></table></figure><h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#顺序启动</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">start etcd</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">start docker</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">start kube-apiserver</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">start kube-controller-manager</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">start kube-scheduler</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">start kubelet</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">start kube-proxy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置开机启动</span></span><br><span class="line"></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">enable etcd</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">enable docker</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">enable kube-apiserver</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">enable kube-controller-manager</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">enable kube-scheduler</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">enable kubelet</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">enable kube-proxy</span></span><br></pre></td></tr></table></figure><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#显示如下信息说明安装成功</span></span><br><span class="line"><span class="meta">[root@node1</span> <span class="string">~]# kubectl version</span></span><br><span class="line"><span class="attr">Client</span> <span class="string">Version: version.Info&#123;Major:&quot;1&quot;, Minor:&quot;5&quot;, GitVersion:&quot;v1.5.2&quot;, GitCommit:&quot;269f928217957e7126dc87e6adfa82242bfe5b1e&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2017-07-03T15:31:10Z&quot;, GoVersion:&quot;go1.7.4&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;&#125;</span></span><br><span class="line"><span class="attr">Server</span> <span class="string">Version: version.Info&#123;Major:&quot;1&quot;, Minor:&quot;5&quot;, GitVersion:&quot;v1.5.2&quot;, GitCommit:&quot;269f928217957e7126dc87e6adfa82242bfe5b1e&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2017-07-03T15:31:10Z&quot;, GoVersion:&quot;go1.7.4&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">[root@node1</span> <span class="string">~]# etcdctl cluster-health</span></span><br><span class="line"><span class="attr">member</span> <span class="string">8e9e05c52164694d is healthy: got healthy result from http://localhost:2379</span></span><br><span class="line"><span class="attr">cluster</span> <span class="string">is healthy</span></span><br><span class="line"><span class="meta">[root@node1</span> <span class="string">~]# </span></span><br></pre></td></tr></table></figure><p>以上方式安装的版本比较老，若想安装新版本请参考下面的方式</p><h4 id="github-地址"><a href="#github-地址" class="headerlink" title="github 地址"></a>github 地址</h4><p><code> https://github.com/easzlab/kubeasz/blob/master/docs/setup/quickStart.md</code></p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;关闭centos-自带的防火墙服务&quot;&gt;&lt;a href=&quot;#关闭centos-自带的防火墙服务&quot; class=&quot;headerlink&quot; title=&quot;关闭centos 自带的防火墙服务&quot;&gt;&lt;/a&gt;关闭centos 自带的防火墙服务&lt;/h4&gt;&lt;figure class=&quot;highlight properties&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;systemctl&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;stop firewalld&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;systemctl&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;disable firewalld&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;配置kubenetes-源&quot;&gt;&lt;a href=&quot;#配置kubenetes-源&quot; class=&quot;headerlink&quot; title=&quot;配置kubenetes 源&quot;&gt;&lt;/a&gt;配置kubenetes 源&lt;/h4&gt;&lt;figure class=&quot;highlight properties&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;vi&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;/etc/yum.repos.d/kubernetes.repo&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;[Kubernetes]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;baseurl&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;enabled&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;gpgcheck&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;repo_gpgcheck&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;gpgkey&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg  http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="ops" scheme="http://yoursite.com/categories/ops/"/>
    
    
    <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>hadoop</title>
    <link href="http://yoursite.com/2020/08/24/hadoop/"/>
    <id>http://yoursite.com/2020/08/24/hadoop/</id>
    <published>2020-08-23T16:00:00.000Z</published>
    <updated>2020-08-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#参考资料</span><br><span class="line">https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;de4d56433848 #hadoop环境搭建</span><br><span class="line">https:&#x2F;&#x2F;www.cnblogs.com&#x2F;zwcoding&#x2F;p&#x2F;9269712.html #hive基本命令</span><br></pre></td></tr></table></figure><h4 id="hdfs命令"><a href="#hdfs命令" class="headerlink" title="hdfs命令"></a>hdfs命令</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 hdfs 上的目录</span></span><br><span class="line"><span class="attr">hadoop</span> <span class="string">fs -ls /</span></span><br><span class="line"><span class="comment"># 创建input目录，源数据的存放地</span></span><br><span class="line"><span class="attr">hadoop</span> <span class="string">fs -mkdir /input</span></span><br><span class="line"><span class="comment"># 如果有output目录，删除；把结果集输出到这里，事先不能存在</span></span><br><span class="line"><span class="attr">hadoop</span> <span class="string">fs -rm -r /output</span></span><br><span class="line"><span class="comment"># 把提前准备好的文本文件上传到 hdfs 的 /input 目录</span></span><br><span class="line"><span class="attr">hadoop</span> <span class="string">fs -put /home/hadoop/data/*.txt /input</span></span><br><span class="line"><span class="comment">#执行程序 wordcount</span></span><br><span class="line"><span class="attr">cd</span> <span class="string">/opt/hadoop-3.3.0/share/hadoop/mapreduce/</span></span><br><span class="line"><span class="attr">hadoop</span> <span class="string">jar hadoop-mapreduce-examples-3.3.0.jar wordcount /input /output</span></span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="hive"><a href="#hive" class="headerlink" title="hive"></a>hive</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#参考https://www.cnblogs.com/lemonu/p/11279810.html</span></span><br><span class="line"><span class="comment">#创建表</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE `docs`(</span></span><br><span class="line">  <span class="meta">`line`</span> <span class="string">string)</span></span><br><span class="line"><span class="attr">ROW</span> <span class="string">FORMAT SERDE </span></span><br><span class="line">  <span class="meta">&#x27;org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe&#x27;</span> <span class="string"></span></span><br><span class="line"><span class="attr">STORED</span> <span class="string">AS INPUTFORMAT </span></span><br><span class="line">  <span class="meta">&#x27;org.apache.hadoop.mapred.TextInputFormat&#x27;</span> <span class="string"></span></span><br><span class="line"><span class="attr">OUTPUTFORMAT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">&#x27;org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat&#x27;;</span></span><br><span class="line"><span class="comment">#从linux本地加载数据到hive表中</span></span><br><span class="line"><span class="meta">hive&gt;</span> <span class="string">load data local inpath &#x27;/opt/docs.txt&#x27; OVERWRITE INTO TABLE docs;</span></span><br><span class="line"><span class="comment">#从HDFS文件系统加载</span></span><br><span class="line"><span class="meta">hive&gt;</span> <span class="string">load data inpath &#x27;/input/docs.txt&#x27; OVERWRITE INTO TABLE docs;</span></span><br><span class="line"><span class="comment">#查看hive表数据</span></span><br><span class="line"><span class="meta">hive&gt;</span> <span class="string">select * from docs;</span></span><br><span class="line"><span class="attr">OK</span></span><br><span class="line"><span class="attr">hello</span> <span class="string">world</span></span><br><span class="line"><span class="attr">hello</span> <span class="string">kwang rzheng</span></span><br><span class="line"><span class="attr">Time</span> <span class="string">taken: 0.284 seconds, Fetched: 2 row(s)</span></span><br><span class="line"><span class="meta">hive&gt;</span> <span class="string"></span></span><br><span class="line"><span class="comment">#分割单词sql实现</span></span><br><span class="line"><span class="meta">hive&gt;</span> <span class="string">SELECT split(line, &#x27;\s&#x27;) AS word FROM docs;</span></span><br><span class="line"><span class="attr">OK</span></span><br><span class="line"><span class="meta">[&quot;hello</span> <span class="string">world&quot;]</span></span><br><span class="line"><span class="meta">[&quot;hello</span> <span class="string">kwang rzheng&quot;]</span></span><br><span class="line"><span class="attr">Time</span> <span class="string">taken: 1.01 seconds, Fetched: 2 row(s)</span></span><br><span class="line"><span class="meta">hive&gt;</span> <span class="string"></span></span><br><span class="line"><span class="comment">#行转列sql实现</span></span><br><span class="line"><span class="meta">hive&gt;</span> <span class="string">SELECT explode(split(line, &#x27; &#x27;)) AS word FROM docs;</span></span><br><span class="line"><span class="attr">OK</span></span><br><span class="line"><span class="attr">hello</span></span><br><span class="line"><span class="attr">world</span></span><br><span class="line"><span class="attr">hello</span></span><br><span class="line"><span class="attr">kwang</span></span><br><span class="line"><span class="attr">rzheng</span></span><br><span class="line"><span class="attr">Time</span> <span class="string">taken: 0.281 seconds, Fetched: 5 row(s)</span></span><br><span class="line"><span class="meta">hive&gt;</span> <span class="string"></span></span><br><span class="line"><span class="comment">#统计计数</span></span><br><span class="line"><span class="meta">hive&gt;</span> <span class="string">SELECT word, count(1) AS count FROM</span></span><br><span class="line">    <span class="meta">&gt;</span>   <span class="string">(SELECT explode(split(line, &#x27; &#x27;)) AS word FROM docs) w</span></span><br><span class="line">    <span class="meta">&gt;</span> <span class="string">GROUP BY word</span></span><br><span class="line">    <span class="meta">&gt;</span> <span class="string">ORDER BY word;</span></span><br><span class="line"><span class="attr">Query</span> <span class="string">ID = root_20200823223201_cbb5849a-664e-462a-a4ee-ca1c04449b18</span></span><br><span class="line"><span class="attr">Total</span> <span class="string">jobs = 2</span></span><br><span class="line"><span class="attr">Launching</span> <span class="string">Job 1 out of 2</span></span><br><span class="line"><span class="attr">Number</span> <span class="string">of reduce tasks not specified. Estimated from input data size: 1</span></span><br><span class="line"><span class="attr">In</span> <span class="string">order to change the average load for a reducer (in bytes):</span></span><br><span class="line">  <span class="attr">set</span> <span class="string">hive.exec.reducers.bytes.per.reducer=&lt;number&gt;</span></span><br><span class="line"><span class="attr">In</span> <span class="string">order to limit the maximum number of reducers:</span></span><br><span class="line">  <span class="attr">set</span> <span class="string">hive.exec.reducers.max=&lt;number&gt;</span></span><br><span class="line"><span class="attr">In</span> <span class="string">order to set a constant number of reducers:</span></span><br><span class="line">  <span class="attr">set</span> <span class="string">mapreduce.job.reduces=&lt;number&gt;</span></span><br><span class="line"><span class="attr">Starting</span> <span class="string">Job = job_1597993447740_0004, Tracking URL = http://hadoop:8088/proxy/application_1597993447740_0004/</span></span><br><span class="line"><span class="attr">Kill</span> <span class="string">Command = /opt/hadoop-3.3.0/bin/mapred job  -kill job_1597993447740_0004</span></span><br><span class="line"><span class="attr">Hadoop</span> <span class="string">job information for Stage-1: number of mappers: 1; number of reducers: 1</span></span><br><span class="line"><span class="meta">2020-08-23</span> <span class="string">22:32:19,078 Stage-1 map = 0%,  reduce = 0%</span></span><br><span class="line"><span class="meta">2020-08-23</span> <span class="string">22:32:27,803 Stage-1 map = 100%,  reduce = 0%, Cumulative CPU 8.15 sec</span></span><br><span class="line"><span class="meta">2020-08-23</span> <span class="string">22:32:36,284 Stage-1 map = 100%,  reduce = 100%, Cumulative CPU 12.9 sec</span></span><br><span class="line"><span class="attr">MapReduce</span> <span class="string">Total cumulative CPU time: 12 seconds 900 msec</span></span><br><span class="line"><span class="attr">Ended</span> <span class="string">Job = job_1597993447740_0004</span></span><br><span class="line"><span class="attr">Launching</span> <span class="string">Job 2 out of 2</span></span><br><span class="line"><span class="attr">Number</span> <span class="string">of reduce tasks determined at compile time: 1</span></span><br><span class="line"><span class="attr">In</span> <span class="string">order to change the average load for a reducer (in bytes):</span></span><br><span class="line">  <span class="attr">set</span> <span class="string">hive.exec.reducers.bytes.per.reducer=&lt;number&gt;</span></span><br><span class="line"><span class="attr">In</span> <span class="string">order to limit the maximum number of reducers:</span></span><br><span class="line">  <span class="attr">set</span> <span class="string">hive.exec.reducers.max=&lt;number&gt;</span></span><br><span class="line"><span class="attr">In</span> <span class="string">order to set a constant number of reducers:</span></span><br><span class="line">  <span class="attr">set</span> <span class="string">mapreduce.job.reduces=&lt;number&gt;</span></span><br><span class="line"><span class="attr">Starting</span> <span class="string">Job = job_1597993447740_0005, Tracking URL = http://hadoop:8088/proxy/application_1597993447740_0005/</span></span><br><span class="line"><span class="attr">Kill</span> <span class="string">Command = /opt/hadoop-3.3.0/bin/mapred job  -kill job_1597993447740_0005</span></span><br><span class="line"><span class="attr">Hadoop</span> <span class="string">job information for Stage-2: number of mappers: 1; number of reducers: 1</span></span><br><span class="line"><span class="meta">2020-08-23</span> <span class="string">22:32:57,016 Stage-2 map = 0%,  reduce = 0%</span></span><br><span class="line"><span class="meta">2020-08-23</span> <span class="string">22:33:04,432 Stage-2 map = 100%,  reduce = 0%, Cumulative CPU 3.73 sec</span></span><br><span class="line"><span class="meta">2020-08-23</span> <span class="string">22:33:14,963 Stage-2 map = 100%,  reduce = 100%, Cumulative CPU 9.41 sec</span></span><br><span class="line"><span class="attr">MapReduce</span> <span class="string">Total cumulative CPU time: 9 seconds 410 msec</span></span><br><span class="line"><span class="attr">Ended</span> <span class="string">Job = job_1597993447740_0005</span></span><br><span class="line"><span class="attr">MapReduce</span> <span class="string">Jobs Launched: </span></span><br><span class="line"><span class="meta">Stage-Stage-1</span>: <span class="string">Map: 1  Reduce: 1   Cumulative CPU: 12.9 sec   HDFS Read: 8161 HDFS Write: 193 SUCCESS</span></span><br><span class="line"><span class="meta">Stage-Stage-2</span>: <span class="string">Map: 1  Reduce: 1   Cumulative CPU: 9.41 sec   HDFS Read: 7613 HDFS Write: 168 SUCCESS</span></span><br><span class="line"><span class="attr">Total</span> <span class="string">MapReduce CPU Time Spent: 22 seconds 310 msec</span></span><br><span class="line"><span class="attr">OK</span></span><br><span class="line"><span class="attr">hello</span>   <span class="string">2</span></span><br><span class="line"><span class="attr">kwang</span>   <span class="string">1</span></span><br><span class="line"><span class="attr">rzheng</span>  <span class="string">1</span></span><br><span class="line"><span class="attr">world</span>   <span class="string">1</span></span><br><span class="line"><span class="attr">Time</span> <span class="string">taken: 74.341 seconds, Fetched: 4 row(s)</span></span><br><span class="line"><span class="meta">hive&gt;</span> <span class="string"></span></span><br></pre></td></tr></table></figure><h4 id="sqoop安装"><a href="#sqoop安装" class="headerlink" title="sqoop安装"></a>sqoop安装</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#参考</span></span><br><span class="line"><span class="attr">https</span>:<span class="string">//blog.csdn.net/wdr2003/article/details/80964590 #安装</span></span><br><span class="line"><span class="attr">http</span>:<span class="string">//www.wuzhixiang.cn/2020/02/13/119/ #问题1</span></span><br><span class="line"><span class="comment">#问题1：SQOOP JAVA.LANG.NOSUCHMETHODERROR: COM.GOOGLE.COMMON.BASE.PRECONDITIONS.CHECKARGUMENT(ZLJAVA/LANG/STRING;LJAVA/LANG/OBJECT;)V</span></span><br><span class="line"><span class="attr">https</span>:<span class="string">//blog.csdn.net/debimeng/article/details/101162801 #问题2</span></span><br><span class="line"><span class="comment">#问题2：Caused by: java.lang.SecurityException: sealing violation: package org.apache.derby.impl.jdbc.authentication is sealed</span></span><br></pre></td></tr></table></figure><h4 id="hadoop配置启动historyserver"><a href="#hadoop配置启动historyserver" class="headerlink" title="hadoop配置启动historyserver"></a>hadoop配置启动historyserver</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#yarn-site.xml增加如下配置，不需要重启hadoop</span></span><br><span class="line"><span class="attr">&lt;!--配置历史服务器--&gt;</span></span><br><span class="line"><span class="meta">&lt;property&gt;</span>  <span class="string"></span></span><br><span class="line"><span class="meta">&lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;</span>  <span class="string"></span></span><br><span class="line"> <span class="meta">&lt;value&gt;192.168.102.84</span>:<span class="string">10020&lt;/value&gt;  </span></span><br><span class="line"><span class="meta">&lt;/property&gt;</span>  <span class="string"></span></span><br><span class="line"><span class="meta">&lt;property&gt;</span>  <span class="string"></span></span><br><span class="line"><span class="meta">&lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt;</span>  <span class="string"></span></span><br><span class="line"><span class="meta">&lt;value&gt;192.168.102.84</span>:<span class="string">19888&lt;/value&gt;  </span></span><br><span class="line"><span class="attr">&lt;/property&gt;</span></span><br><span class="line"><span class="meta">mr-jobhistory-daemon.sh</span> <span class="string">start historyserver</span></span><br></pre></td></tr></table></figure><h4 id="spark-sql"><a href="#spark-sql" class="headerlink" title="spark-sql"></a>spark-sql</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[root@hadoop</span> <span class="string">bin]# ./spark-shell --master local[2]</span></span><br><span class="line"><span class="meta">scala&gt;</span> <span class="string">val lineRDD= sc.textFile(&quot;/input/person.txt&quot;).map(_.split(&quot; &quot;))</span></span><br><span class="line"><span class="attr">lineRDD</span>: <span class="string">org.apache.spark.rdd.RDD[Array[String]] = MapPartitionsRDD[2] at map at &lt;console&gt;:24</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义case class（相当于表的schema）</span></span><br><span class="line"><span class="meta">scala&gt;</span> <span class="string">case class Person(id:Int, name:String, age:Int) </span></span><br><span class="line"><span class="attr">defined</span> <span class="string">class Person</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将RDD和case class关联</span></span><br><span class="line"><span class="meta">scala&gt;</span> <span class="string">val personRDD = lineRDD.map(x =&gt; Person(x(0).toInt, x(1), x(2).toInt)) </span></span><br><span class="line"><span class="attr">personRDD</span>: <span class="string">org.apache.spark.rdd.RDD[Person] = MapPartitionsRDD[3] at map at &lt;console&gt;:27</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将RDD转换成DataFrame</span></span><br><span class="line"><span class="meta">scala&gt;</span> <span class="string">val personDF = personRDD.toDF </span></span><br><span class="line"><span class="attr">personDF</span>: <span class="string">org.apache.spark.sql.DataFrame = [id: int, name: string ... 1 more field]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#对DataFrame进行处理</span></span><br><span class="line"><span class="meta">scala&gt;</span> <span class="string">personDF.show </span></span><br><span class="line"><span class="meta">+---+--------+---+</span>                                                              <span class="string"></span></span><br><span class="line"><span class="meta">|</span> <span class="string">id|    name|age|</span></span><br><span class="line"><span class="attr">+---+--------+---+</span></span><br><span class="line"><span class="meta">|</span>  <span class="string">1|zhangsan| 20|</span></span><br><span class="line"><span class="meta">|</span>  <span class="string">2|    lisi| 29|</span></span><br><span class="line"><span class="meta">|</span>  <span class="string">3|  wangwu| 25|</span></span><br><span class="line"><span class="meta">|</span>  <span class="string">4| zhaoliu| 30|</span></span><br><span class="line"><span class="meta">|</span>  <span class="string">5|  tianqi| 35|</span></span><br><span class="line"><span class="meta">|</span>  <span class="string">6|    kobe| 40|</span></span><br><span class="line"><span class="attr">+---+--------+---+</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">scala&gt;</span> <span class="string">personDF.printSchema</span></span><br><span class="line"><span class="attr">root</span></span><br><span class="line"> <span class="meta">|--</span> <span class="string">id: integer (nullable = false)</span></span><br><span class="line"> <span class="meta">|--</span> <span class="string">name: string (nullable = true)</span></span><br><span class="line"> <span class="meta">|--</span> <span class="string">age: integer (nullable = false)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#https://blog.csdn.net/qq_44509920/article/details/105477738</span></span><br></pre></td></tr></table></figure><h4 id="Hbase"><a href="#Hbase" class="headerlink" title="Hbase"></a>Hbase</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#参考https://blog.csdn.net/xu_cxiang/article/details/104530854</span></span><br><span class="line"><span class="comment">#单机模式</span></span><br><span class="line"><span class="comment">#系统环境变量</span></span><br><span class="line"><span class="attr">vi</span> <span class="string">/etc/profile</span></span><br><span class="line"><span class="attr">JAVA_HOME</span>=<span class="string">/usr/java/jdk1.8.0_144</span></span><br><span class="line"><span class="attr">PATH</span>=<span class="string">$JAVA_HOME/bin:$PATH</span></span><br><span class="line"><span class="attr">CLASSPATH</span>=<span class="string">.:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar</span></span><br><span class="line"><span class="attr">export</span> <span class="string">PATH JAVA_HOME CLASSPATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#set hadoop path</span></span><br><span class="line"><span class="attr">export</span> <span class="string">HADOOP_HOME=/opt/hadoop-3.3.0</span></span><br><span class="line"><span class="attr">export</span> <span class="string">PATH=$PATH:$HADOOP_HOME/bin</span></span><br><span class="line"></span><br><span class="line"><span class="attr">export</span> <span class="string">SQOOP_HOME=/opt/sqoop-1.99.7</span></span><br><span class="line"><span class="comment">#export SQOOP_SERVER_EXTRA_LIB=$SQOOP_HOME/extra</span></span><br><span class="line"><span class="attr">export</span> <span class="string">PATH=$PATH:$SQOOP_HOME/bin</span></span><br><span class="line"></span><br><span class="line"><span class="attr">export</span> <span class="string">HBASE_HOME=/opt/hbase-2.2.5</span></span><br><span class="line"><span class="attr">export</span> <span class="string">PATH=.:$&#123;JAVA_HOME&#125;/bin:$&#123;HADOOP_HOME&#125;/bin:$&#123;HBASE_HOME&#125;/bin:$PATH</span></span><br><span class="line"><span class="comment">#hbase 配置文件</span></span><br><span class="line"><span class="attr">vi</span> <span class="string">hbase-env.sh</span></span><br><span class="line"><span class="attr">export</span> <span class="string">JAVA_HOME=/usr/java/jdk1.8.0_144</span></span><br><span class="line"><span class="attr">export</span> <span class="string">HADOOP_HOME=/opt/hadoop-3.3.0</span></span><br><span class="line"><span class="attr">export</span> <span class="string">HBASE_HOME=/opt/hbase-2.2.5</span></span><br><span class="line"><span class="attr">export</span> <span class="string">HBASE_CLASSPATH=/opt/hadoop-3.3.0/etc/hadoop</span></span><br><span class="line"><span class="attr">export</span> <span class="string">HBASE_PID_DIR=/root/hbase/pids</span></span><br><span class="line"><span class="attr">export</span> <span class="string">HBASE_MANAGES_ZK=true</span></span><br><span class="line"><span class="comment">#hbase 配置文件</span></span><br><span class="line"><span class="attr">vi</span> <span class="string">hbase-site.xml</span></span><br><span class="line"><span class="attr">&lt;configuration&gt;</span></span><br><span class="line">  <span class="attr">&lt;property&gt;</span></span><br><span class="line">      <span class="attr">&lt;name&gt;hbase.rootdir&lt;/name&gt;</span></span><br><span class="line">      <span class="meta">&lt;value&gt;file</span>:<span class="string">///data/hbase&lt;/value&gt;</span></span><br><span class="line">  <span class="attr">&lt;/property&gt;</span></span><br><span class="line">   <span class="attr">&lt;property&gt;</span></span><br><span class="line">      <span class="attr">&lt;name&gt;hbase.tmp.dir&lt;/name&gt;</span></span><br><span class="line">      <span class="attr">&lt;value&gt;/data/tmp&lt;/value&gt;</span></span><br><span class="line">  <span class="attr">&lt;/property&gt;</span></span><br><span class="line">  <span class="attr">&lt;property&gt;</span></span><br><span class="line">      <span class="attr">&lt;name&gt;hbase.cluster.distributed&lt;/name&gt;</span></span><br><span class="line">      <span class="attr">&lt;value&gt;true&lt;/value&gt;</span></span><br><span class="line">  <span class="attr">&lt;/property&gt;</span></span><br><span class="line"><span class="comment">  # 该处value值填写 本机IP 或 host值</span></span><br><span class="line">  <span class="attr">&lt;property&gt;</span></span><br><span class="line">      <span class="attr">&lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;</span></span><br><span class="line">      <span class="attr">&lt;value&gt;127.0.0.1&lt;/value&gt;</span></span><br><span class="line">  <span class="attr">&lt;/property&gt;</span></span><br><span class="line">  <span class="attr">&lt;property&gt;</span></span><br><span class="line">      <span class="attr">&lt;name&gt;hbase.unsafe.stream.capability.enforce&lt;/name&gt;</span></span><br><span class="line">      <span class="attr">&lt;value&gt;false&lt;/value&gt;</span></span><br><span class="line">      <span class="attr">&lt;/property&gt;</span></span><br><span class="line"><span class="attr">&lt;/configuration&gt;</span></span><br><span class="line"><span class="comment">#连接Hbase</span></span><br><span class="line"><span class="meta">./hbase</span> <span class="string">shell</span></span><br><span class="line"><span class="comment">#查看帮助信息, 敲</span></span><br><span class="line"><span class="meta">hbase(main)</span>:<span class="string">004:0&gt; help</span></span><br><span class="line"><span class="comment">#创建一个表，必须要指定表名称和列簇名</span></span><br><span class="line"><span class="meta">hbase(main)</span>:<span class="string">002:0&gt; create &#x27;test&#x27;, &#x27;cf&#x27;</span></span><br><span class="line"><span class="attr">Created</span> <span class="string">table test</span></span><br><span class="line"><span class="attr">Took</span> <span class="string">2.1134 seconds</span></span><br><span class="line">=&gt; Hbase::Table - test</span><br><span class="line"><span class="comment">#列出关于你的表的信息,list &#x27;sometable&#x27;</span></span><br><span class="line"><span class="meta">hbase(main)</span>:<span class="string">003:0&gt; list &#x27;test&#x27;</span></span><br><span class="line"><span class="attr">TABLE</span>     <span class="string"></span></span><br><span class="line"><span class="attr">test</span>          <span class="string"></span></span><br><span class="line"><span class="attr">1</span> <span class="string">row(s)</span></span><br><span class="line"><span class="attr">Took</span> <span class="string">0.0673 seconds                                                                       =&gt; [&quot;test&quot;]</span></span><br><span class="line"><span class="comment">#查看表更为详细的信息，使用describe命令</span></span><br><span class="line"><span class="meta">hbase(main)</span>:<span class="string">004:0&gt; describe &#x27;test&#x27;</span></span><br><span class="line"><span class="attr">Table</span> <span class="string">test is ENABLED          </span></span><br><span class="line"><span class="attr">test</span>     <span class="string"></span></span><br><span class="line"><span class="attr">COLUMN</span> <span class="string">FAMILIES DESCRIPTION     </span></span><br><span class="line"><span class="meta">&#123;NAME</span> =<span class="string">&gt; &#x27;cf&#x27;, VERSIONS =&gt; &#x27;1&#x27;, EVICT_BLOCKS_ON_CLOSE =&gt; &#x27;false&#x27;, NEW_VERSION_BEHAVIOR =&gt; &#x27;false&#x27;, KEEP_DELETED_CELLS =&gt; &#x27;FALSE&#x27;, CACHE_DATA_ON_WRITE =&gt; &#x27;false&#x27;, DATA_BLOCK_ENCODING =&gt; &#x27;NON</span></span><br><span class="line"><span class="meta">E&#x27;,</span> <span class="string">TTL =&gt; &#x27;FOREVER&#x27;, MIN_VERSIONS =&gt; &#x27;0&#x27;, REPLICATION_SCOPE =&gt; &#x27;0&#x27;, BLOOMFILTER =&gt; &#x27;ROW&#x27;, CACHE_INDEX_ON_WRITE =&gt; &#x27;false&#x27;, IN_MEMORY =&gt; &#x27;false&#x27;, CACHE_BLOOMS_ON_WRITE =&gt; &#x27;false&#x27;, PREFETCH_</span></span><br><span class="line"><span class="attr">BLOCKS_ON_OPEN</span> =<span class="string">&gt; &#x27;false&#x27;, COMPRESSION =&gt; &#x27;NONE&#x27;, BLOCKCACHE =&gt; &#x27;true&#x27;, BLOCKSIZE =&gt; &#x27;65536&#x27;&#125;</span></span><br><span class="line"><span class="comment">#把数据放到表中</span></span><br><span class="line"><span class="meta">hbase(main)</span>:<span class="string">005:0&gt; put &#x27;test&#x27;,&#x27;row1&#x27;,&#x27;cf:a&#x27;,&#x27;value1&#x27;</span></span><br><span class="line"><span class="attr">Took</span> <span class="string">0.1518 seconds</span></span><br><span class="line"><span class="meta">hbase(main)</span>:<span class="string">006:0&gt; put &#x27;test&#x27;,&#x27;row2&#x27;,&#x27;cf:b&#x27;,&#x27;value2&#x27;</span></span><br><span class="line"><span class="attr">Took</span> <span class="string">0.0159 seconds                                                                       </span></span><br><span class="line"><span class="meta">hbase(main)</span>:<span class="string">007:0&gt; put &#x27;test&#x27;,&#x27;row3&#x27;,&#x27;cf:c&#x27;,&#x27;value3&#x27;</span></span><br><span class="line"><span class="attr">Took</span> <span class="string">0.0156 seconds    </span></span><br><span class="line"><span class="comment">#查看表中的所有数据</span></span><br><span class="line"><span class="meta">hbase(main)</span>:<span class="string">008:0&gt; scan &#x27;test&#x27;</span></span><br><span class="line"><span class="attr">ROW</span>                                              <span class="string">COLUMN+CELL  </span></span><br><span class="line"> <span class="attr">row1</span>                                            <span class="string">column=cf:a, timestamp=1599015000632, value=value1            </span></span><br><span class="line"> <span class="attr">row2</span>                                            <span class="string">column=cf:b, timestamp=1599015029440, value=value2          </span></span><br><span class="line"> <span class="attr">row3</span>                                            <span class="string">column=cf:c, timestamp=1599015037191, value=value3           </span></span><br><span class="line"><span class="attr">3</span> <span class="string">row(s)</span></span><br><span class="line"><span class="attr">Took</span> <span class="string">0.0869 seconds</span></span><br><span class="line"><span class="comment">#获取单行的数据</span></span><br><span class="line"><span class="meta">hbase(main)</span>:<span class="string">009:0&gt; get &#x27;test&#x27;,&#x27;row1&#x27;</span></span><br><span class="line"><span class="attr">COLUMN</span>                                           <span class="string">CELL</span></span><br><span class="line"> <span class="attr">cf</span>:<span class="string">a                                            timestamp=1599015000632, value=value1</span></span><br><span class="line"><span class="attr">1</span> <span class="string">row(s)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#参考资料&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;https:&amp;#x2F;&amp;#x2F;www.jianshu.com&amp;#x2F;p&amp;#x2F;de4d56433848 #hadoop环境搭建&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;https:&amp;#x2F;&amp;#x2F;www.cnblogs.com&amp;#x2F;zwcoding&amp;#x2F;p&amp;#x2F;9269712.html #hive基本命令&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;hdfs命令&quot;&gt;&lt;a href=&quot;#hdfs命令&quot; class=&quot;headerlink&quot; title=&quot;hdfs命令&quot;&gt;&lt;/a&gt;hdfs命令&lt;/h4&gt;&lt;figure class=&quot;highlight properties&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 查看 hdfs 上的目录&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;hadoop&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;fs -ls /&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 创建input目录，源数据的存放地&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;hadoop&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;fs -mkdir /input&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 如果有output目录，删除；把结果集输出到这里，事先不能存在&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;hadoop&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;fs -rm -r /output&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 把提前准备好的文本文件上传到 hdfs 的 /input 目录&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;hadoop&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;fs -put /home/hadoop/data/*.txt /input&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#执行程序 wordcount&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;/opt/hadoop-3.3.0/share/hadoop/mapreduce/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;hadoop&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;jar hadoop-mapreduce-examples-3.3.0.jar wordcount /input /output&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="ops" scheme="http://yoursite.com/categories/ops/"/>
    
    
    <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>大数据</title>
    <link href="http://yoursite.com/2020/08/20/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/2020/08/20/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/</id>
    <published>2020-08-19T16:00:00.000Z</published>
    <updated>2020-08-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-组件简介"><a href="#1-组件简介" class="headerlink" title="1.组件简介"></a>1.组件简介</h4><p><img src="https://raw.githubusercontent.com/hzq82/img/master/img/bigdata.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#参考资料</span><br><span class="line">https:&#x2F;&#x2F;blog.csdn.net&#x2F;sinat_35322593&#x2F;article&#x2F;details&#x2F;79883639</span><br><span class="line">https:&#x2F;&#x2F;blog.csdn.net&#x2F;Mei_ZS&#x2F;article&#x2F;details&#x2F;93191279</span><br><span class="line">https:&#x2F;&#x2F;blog.csdn.net&#x2F;NextAction&#x2F;article&#x2F;details&#x2F;78993014 #生态圈基本组件</span><br></pre></td></tr></table></figure><h4 id="2-HDFS"><a href="#2-HDFS" class="headerlink" title="2.HDFS"></a>2.HDFS</h4><p>&#8195;&#8195;它是由Google File System而来，全称是Hadoop Distributed File System，是Hadoop的分布式文件系统，有许多机器组成的，可以存储大型数据文件。</p><p>&#8195;&#8195;它是由NameNode和DataNode组成，NameNode可以配置成HA(高可用)，避免单点故障。一般用Zookeeper来处理。两个NameNode是同步的。</p><h4 id="3-MapReduce"><a href="#3-MapReduce" class="headerlink" title="3.MapReduce"></a>3.MapReduce</h4><p>&#8195;&#8195;主要由Google Reduce而来，它简化了大型数据的处理，是一个并行的，分布式处理的编程模型。</p><p>&#8195;&#8195;MapReduce是一种分布式计算模型，用以进行海量数据的计算，它将计算抽象成Map和Reduce两部分，其中Map对数据集上的独立元素进行指定的操作，生成键-值对形式中间结果。Reduce则对中间结果中相同“键”的所有“值”进行规约，以得到最终结果。</p><p>&#8195;&#8195;hadoop2.0它是基于YARN框架构建的。YARN的全称是Yet-Another-Resource-Negotiator。Yarn可以运用在S3|Spark等上。</p><p>&#8195;&#8195;MapReduce是一个软件框架，基于它编写出来的应用可以以并行计算的方式在多个计算机节点上处理大量的数据。MapReduce为分析海量复杂的数据提供了分析能力。</p><a id="more"></a><h4 id="4-Spark"><a href="#4-Spark" class="headerlink" title="4.Spark"></a>4.Spark</h4><p>&#8195;&#8195;Apache Spark 是专为大规模数据处理而设计的快速通用的计算引擎。Spark是UC Berkeley AMP lab (加州大学伯克利分校的AMP实验室)所开源的类Hadoop MapReduce的通用并行框架，Spark，拥有Hadoop MapReduce所具有的优点；但不同于MapReduce的是——Job中间输出结果可以保存在内存中，从而不再需要读写HDFS，因此Spark能更好地适用于数据挖掘与机器学习等需要迭代的MapReduce的算法。</p><p>&#8195;&#8195;Spark 是一种与 <a href="https://baike.baidu.com/item/Hadoop">Hadoop</a> 相似的开源集群计算环境，但是两者之间还存在一些不同之处，这些有用的不同之处使 Spark 在某些工作负载方面表现得更加优越，换句话说，Spark 启用了内存分布数据集，除了能够提供交互式查询外，它还可以优化迭代工作负载。</p><p>&#8195;&#8195;Spark 是在 <a href="https://baike.baidu.com/item/Scala">Scala</a> 语言中实现的，它将 Scala 用作其应用程序框架。与 Hadoop 不同，Spark 和 Scala 能够紧密集成，其中的 Scala 可以像操作本地集合对象一样轻松地操作分布式数据集。</p><p>Spark 主要有三个特点 ：</p><p>&#8195;&#8195;首先，高级 API 剥离了对集群本身的关注，Spark 应用开发者可以专注于应用所要做的计算本身。</p><p>&#8195;&#8195;其次，Spark 很快，支持交互式计算和复杂算法。</p><p>&#8195;&#8195;最后，Spark 是一个通用引擎，可用它来完成各种各样的运算，包括 SQL 查询、文本处理、机器学习等，而在 Spark 出现之前，我们一般需要学习各种各样的引擎来分别处理这些需求。</p><h4 id="5-Hbase"><a href="#5-Hbase" class="headerlink" title="5.Hbase"></a>5.Hbase</h4><p>&#8195;&#8195;HBase是一个分布式的、面向列的开源数据库，该技术来源于 Fay Chang 所撰写的Google论文“Bigtable：一个结构化数据的<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F">分布式存储系统</a>”。就像Bigtable利用了Google文件系统（File System）所提供的分布式数据存储一样，HBase在Hadoop之上提供了类似于Bigtable的能力。HBase是Apache的Hadoop项目的子项目。HBase不同于一般的关系数据库，它是一个适合于非结构化数据存储的数据库。另一个不同的是HBase基于列的而不是基于行的模式。</p><p>&#8195;&#8195;HBase – Hadoop Database，是一个高<a href="https://baike.baidu.com/item/%E5%8F%AF%E9%9D%A0">可靠</a>性、高性能、面向列、可伸缩的<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F">分布式存储系统</a>，利用HBase技术可在廉价PC Server上搭建起大规模<a href="https://baike.baidu.com/item/%E7%BB%93%E6%9E%84">结构</a>化<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8">存储</a>集群。</p><h4 id="6-Hive"><a href="#6-Hive" class="headerlink" title="6.Hive"></a>6.Hive</h4><p>&#8195;&#8195;hive是基于Hadoop的一个<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93">数据仓库</a>工具，可以将结构化的数据文件映射为一张数据库表，并提供简单的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。 其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93">数据仓库</a>的统计分析</p><p>hbase 和 hive区别 <a href="https://blog.csdn.net/wshyb0314/article/details/81475475">https://blog.csdn.net/wshyb0314/article/details/81475475</a></p><h4 id="7-YARN"><a href="#7-YARN" class="headerlink" title="7.YARN"></a>7.YARN</h4><p>&#8195;&#8195;YARN是<a href="http://lib.csdn.net/base/hadoop">Hadoop</a> 2.0中的资源管理系统，它的基本设计思想是将MRv1中的JobTracker拆分成了两个独立的服务：一个全局的资源管理器ResourceManager和每个应用程序特有的ApplicationMaster。其中ResourceManager负责整个系统的资源管理和分配，而ApplicationMaster负责单个应用程序的管理。</p><p>&#8195;&#8195;YARN总体上仍然是Master/Slave结构，在整个资源管理框架中，ResourceManager为Master，NodeManager为Slave，ResourceManager负责对各个NodeManager上的资源进行统一管理和调度。当用户提交一个应用程序时，需要提供一个用以跟踪和管理这个程序的ApplicationMaster，它负责向ResourceManager申请资源，并要求NodeManger启动可以占用一定资源的任务。由于不同的ApplicationMaster被分布到不同的节点上，因此它们之间不会相互影响。</p><h4 id="8-Pig"><a href="#8-Pig" class="headerlink" title="8.Pig"></a>8.Pig</h4><p>&#8195;&#8195;Pig是一种探索大规模数据集的脚本语言。MapReducer的一个主要的缺点就是开发的周期太长了。我们要编写mapper和reducer，然后对代码进行编译打出jar包，提交到本地的JVM或者是hadoop的集群上，最后获取结果，这个周期是非常耗时的，即使使用Streaming(它是hadoop的一个工具，用来创建和运行一类特殊的map/reduce作业。所谓的特殊的map/reduce作业可以是可执行文件或脚本本件（python、PHP、c等）。Streaming使用“标准输入”和“标准输出”与我们编写的Map和Reduce进行数据的交换。由此可知，任何能够使用“标准输入”和“标准输出”的编程语言都可以用来编写MapReduce程序)能在这个过程中除去代码的编译和打包的步骤，但是这一个过程还是很耗时，Pig的强大之处就是他只要几行Pig Latin代码就能处理TB级别的数据。Pig提供了多个命令用于检查和处理程序中的数据结构，因此它能很好的支持我们写查询。Pig的一个很有用的特性就是它支持在输入数据中有代表性的一个小的数据集上试运行。所以。我们在处理大的数据集前可以用那一个小的数据集检查我们的程序是不是有错误的。</p><p>&#8195;&#8195;Pig为大型的数据集的处理提供了更高层次的抽象。MapReducer能够让我们自己定义连续执行的map和reduce函数，但是数据处理往往需要很多的MapReducer过程才能实现，所以将数据处理要求改写成MapReducer模式是很复杂的。和MapReducer相比，Pig提供了更加丰富的数据结构，一般都是多值和嵌套的数据结构。Pig还提供了一套更强大的数据交换操作，包括了MapReducer中被忽视的”join”操作</p><p>&#8195;&#8195;Pig 被设计为可以扩展的，处理路径上的每一个部分，载入，存储，过滤，分组，连接，都是可以定制的，这些操作都可以使用用户定义函数（user-defined function,UDF）进行修改，这些函数作用于Pig的嵌套数据模型。因此，它们可以在底层与Pig的操作集成，UDF的另外的一个好处是它们比MapReducer程序开发的库更易于重用。</p><p>&#8195;&#8195;但是。Pig并不适合处理所有的“数据处理”任务。和MapReducer一样，它是为数据批处理而设计的，如果想执行的查询只涉及一个大型数据集的一小部分数据，Pig的实现不是很好，因为它要扫描整个数据集或其中的很大一部分。</p><h4 id="9-sqoop"><a href="#9-sqoop" class="headerlink" title="9.sqoop"></a>9.sqoop</h4><p>&#8195;&#8195;Hadoop正成为企业用于大数据分析的最热门选择，但想将你的数据移植过去并不容易。Apache  Sqoop正在加紧帮助客户将重要数据从数据库移到Hadoop。随着Hadoop和关系型数据库之间的数据移动渐渐变成一个标准的流程，云管理员们能够利用Sqoop的并行批量数据加载能力来简化这一流程，降低编写自定义数据加载脚本的需求。</p><p>&#8195;&#8195;Apache Sqoop（SQL-to-Hadoop）项目旨在协助 RDBMS 与 Hadoop 之间进行高效的大数据交流。用户可以在  Sqoop 的帮助下，轻松地把关系型数据库的数据导入到 Hadoop 与其相关的系统 (如HBase和Hive)中；同时也可以把数据从  Hadoop 系统里抽取并导出到关系型数据库里。因此，可以说Sqoop就是一个桥梁，连接了关系型数据库与Hadoop。</p><p><img src="https://raw.githubusercontent.com/hzq82/img/master/img/20170426191955111.png"></p><h4 id="10-Flume"><a href="#10-Flume" class="headerlink" title="10.Flume"></a>10.Flume</h4><p>&#8195;&#8195;Flume是Cloudera提供的一个高可用的，高可靠的，分布式的海量日志采集、聚合和传输的软件。<br>&#8195;&#8195;Flume的核心是把数据从数据源(source)收集过来，再将收集到的数据送到指定的目的地(sink)。为了保证输送的过程一定成功，在送到目的地(sink)之前，会先缓存数据(channel),待数据真正到达目的地(sink)后，flume再删除自己缓存的数据。</p><h4 id="11-kafka"><a href="#11-kafka" class="headerlink" title="11.kafka"></a>11.kafka</h4><p>&#8195;&#8195;Kafka是Linkedin于2010年12月开源的消息系统，主要用于处理活跃的流式数据。活跃的流式数据在Web网站应用中非常常见，这些数据包括网站的PV（Page View），用户访问了什么内容，搜索了什么内容等。这些数据通常以日志的形式记录下来，然后每隔一段时间进行一次统计。</p><h4 id="12-Mahout"><a href="#12-Mahout" class="headerlink" title="12.Mahout"></a>12.Mahout</h4><p>&#8195;&#8195;Mahout源于2008年，最初是Apache Lucent的子项目，现在发展为Apache的顶级项目。Mahout是一个可扩展的机器学习和数据挖掘库。</p><h4 id="13-Ambari"><a href="#13-Ambari" class="headerlink" title="13.Ambari"></a>13.Ambari</h4><p>&#8195;&#8195;Ambari是一个基于Web的工具，用于配置、管理和监控Hadoop集群。Ambari以图形化的方式 查看MapReduce、Pig、Hive应用程序的运行状况，方便用户进行问题诊断和优化。</p><h4 id="14-Storm"><a href="#14-Storm" class="headerlink" title="14.Storm"></a>14.Storm</h4><p>&#8195;&#8195;Storm 是一个分布式实时大数据处理系统，可以帮助我们方便地处理海量数据，具有高可靠、高容错、高扩展的特点。</p><p>&#8195;&#8195;Storm 是流式框架，有很高的数据吞吐能力，Strom 本身是无状态的，通过 ZooKeeper 管理分布式集群环境和集群状态。</p><p>&#8195;&#8195;Strom 的安装和使用都很简单，但功能强大，可以并行地对实时数据流进行各种处理。</p><p>Storm 与 Hadoop 都用来处理大数据，那么它们的关系是怎样的呢？</p><p>Hadoop 是强大的大数据处理系统，但是在实时计算方面不够擅长；Storm的核心功能就是提供强大的实时处理能力，但没有涉及存储；所以 Storm 与 Hadoop 即不同也互补。</p><p>它们的最主要的区别例如：</p><ol><li>Storm 是实时流处理模式，Hadoop 是批处理模式；</li><li>Storm 就像一条川流不息的河流，只要不是意外或者人为停止，它就会一直运行，Hadoop 是在需要时执行 MapReduce 任务，执行完成后停止；</li><li>在处理时间上，Storm 每秒可以处理数万条消息，HDFS+MapReduce 处理大量数据时通常需要几分钟到几小时。</li></ol><p>参考资料# <a href="https://dbaplus.cn/news-73-1331-1.html">https://dbaplus.cn/news-73-1331-1.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;1-组件简介&quot;&gt;&lt;a href=&quot;#1-组件简介&quot; class=&quot;headerlink&quot; title=&quot;1.组件简介&quot;&gt;&lt;/a&gt;1.组件简介&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/hzq82/img/master/img/bigdata.png&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#参考资料&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;https:&amp;#x2F;&amp;#x2F;blog.csdn.net&amp;#x2F;sinat_35322593&amp;#x2F;article&amp;#x2F;details&amp;#x2F;79883639&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;https:&amp;#x2F;&amp;#x2F;blog.csdn.net&amp;#x2F;Mei_ZS&amp;#x2F;article&amp;#x2F;details&amp;#x2F;93191279&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;https:&amp;#x2F;&amp;#x2F;blog.csdn.net&amp;#x2F;NextAction&amp;#x2F;article&amp;#x2F;details&amp;#x2F;78993014 #生态圈基本组件&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;2-HDFS&quot;&gt;&lt;a href=&quot;#2-HDFS&quot; class=&quot;headerlink&quot; title=&quot;2.HDFS&quot;&gt;&lt;/a&gt;2.HDFS&lt;/h4&gt;&lt;p&gt;&amp;#8195;&amp;#8195;它是由Google File System而来，全称是Hadoop Distributed File System，是Hadoop的分布式文件系统，有许多机器组成的，可以存储大型数据文件。&lt;/p&gt;
&lt;p&gt;&amp;#8195;&amp;#8195;它是由NameNode和DataNode组成，NameNode可以配置成HA(高可用)，避免单点故障。一般用Zookeeper来处理。两个NameNode是同步的。&lt;/p&gt;
&lt;h4 id=&quot;3-MapReduce&quot;&gt;&lt;a href=&quot;#3-MapReduce&quot; class=&quot;headerlink&quot; title=&quot;3.MapReduce&quot;&gt;&lt;/a&gt;3.MapReduce&lt;/h4&gt;&lt;p&gt;&amp;#8195;&amp;#8195;主要由Google Reduce而来，它简化了大型数据的处理，是一个并行的，分布式处理的编程模型。&lt;/p&gt;
&lt;p&gt;&amp;#8195;&amp;#8195;MapReduce是一种分布式计算模型，用以进行海量数据的计算，它将计算抽象成Map和Reduce两部分，其中Map对数据集上的独立元素进行指定的操作，生成键-值对形式中间结果。Reduce则对中间结果中相同“键”的所有“值”进行规约，以得到最终结果。&lt;/p&gt;
&lt;p&gt;&amp;#8195;&amp;#8195;hadoop2.0它是基于YARN框架构建的。YARN的全称是Yet-Another-Resource-Negotiator。Yarn可以运用在S3|Spark等上。&lt;/p&gt;
&lt;p&gt;&amp;#8195;&amp;#8195;MapReduce是一个软件框架，基于它编写出来的应用可以以并行计算的方式在多个计算机节点上处理大量的数据。MapReduce为分析海量复杂的数据提供了分析能力。&lt;/p&gt;</summary>
    
    
    
    <category term="ops" scheme="http://yoursite.com/categories/ops/"/>
    
    
    <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>网络知识</title>
    <link href="http://yoursite.com/2020/08/14/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2020/08/14/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/</id>
    <published>2020-08-13T16:00:00.000Z</published>
    <updated>2020-08-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="https-通讯流程"><a href="#https-通讯流程" class="headerlink" title="https 通讯流程"></a>https 通讯流程</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1）Client发起请求；</span></span><br><span class="line"><span class="attr">2）Server端响应请求，并在之后将证书发送至Client；</span></span><br><span class="line"><span class="attr">3）Client使用认证机构的公钥认证证书，并从证书中取出Server端公钥；</span></span><br><span class="line"><span class="attr">4）Client使用公钥加密一个随机秘钥，并传到Server；</span></span><br><span class="line"><span class="attr">5）Server使用私钥解密出随机秘钥；</span></span><br><span class="line"><span class="attr">6）通信双方使用随机秘钥最为对称秘钥进行加密解密。</span></span><br><span class="line"><span class="comment">#参考 http://www.52im.net/thread-1751-1-1.html</span></span><br></pre></td></tr></table></figure><h4 id="traceroute的基本原理"><a href="#traceroute的基本原理" class="headerlink" title="traceroute的基本原理"></a>traceroute的基本原理</h4><p><img src="http://www.52im.net/data/attachment/forum/201809/21/161014pkzjhk8h93ozr89r.png"></p><p><img src="http://www.52im.net/data/attachment/forum/201809/21/161013ss7klzmlm3dh9xis.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">具体做法就是：</span><br><span class="line">1.Traceroute会设置特殊的TTL值，来追踪源主机和目标主机之间的路由数。首先它给目标主机发送一个 TTL&#x3D;1 的UDP数据包，那么这个数据包一旦在路上遇到一个路由器，TTL就变成了0（TTL规则是每经过一个路由器都会减1），因为TTL&#x3D;0了，所以路由器就会把这个数据包丢掉，然后产生一个错误类型（超时）的ICMP数据包回发给源主机，也就是差错包。这个时候源主机就拿到了第一个路由节点的IP和相关信息了;  </span><br><span class="line">2.接着，源主机再给目标主机发一个 TTL&#x3D;2 的UDP数据包，依旧上述流程走一遍，就知道第二个路由节点的IP和耗时情况等信息了;  </span><br><span class="line">3.如此反复进行，Traceroute就可以拿到从主机A到主机B之间所有路由器的信息了。</span><br><span class="line">4.但是有个问题是，如果数据包到达了目标主机的话，即使目标主机接收到TTL值为1的IP数据包，它也是不会丢弃该数据包的，也不会产生一份超时的ICMP回发数据包的，因为数据包已经达到了目的地嘛。那我们应该怎么认定数据包是否达到了目标主机呢?  </span><br><span class="line">5.Traceroute的方法是在源主机发送UDP数据包给目标主机的时候，会设置一个不可能达到的目标端口号（例如大于30000的端口号），那么当这个数据包真的到达目标主机的时候，目标主机发现没有对应的端口号，因此会产生一份“端口不可达”的错误ICMP报文返回给源主机.  </span><br><span class="line">#参考资料 http:&#x2F;&#x2F;www.52im.net&#x2F;thread-1973-1-1.html</span><br></pre></td></tr></table></figure><h4 id="同步I-O、异步I-O与阻塞I-O、非阻塞I-O的区别"><a href="#同步I-O、异步I-O与阻塞I-O、非阻塞I-O的区别" class="headerlink" title="同步I/O、异步I/O与阻塞I/O、非阻塞I/O的区别"></a>同步I/O、异步I/O与阻塞I/O、非阻塞I/O的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">一、I&#x2F;O</span><br><span class="line">　　I&#x2F;O (Input&#x2F;Output，输入&#x2F;输出)即数据的读取（接收）或写入（发送）操作。</span><br><span class="line">　　通常用户进程中的一个完整I&#x2F;O分为两阶段：用户进程空间&lt;--&gt;内核空间、内核空间&lt;--&gt;设备空间（磁盘、网络等）。</span><br><span class="line">　　I&#x2F;O有内存I&#x2F;O、网络I&#x2F;O和磁盘I&#x2F;O三种，通常我们说的IO指的是后两者。</span><br><span class="line">二、同步I&#x2F;O与异步I&#x2F;O</span><br><span class="line">　　同步和异步关注的是消息通信机制 (synchronous communication&#x2F; asynchronous communication)</span><br><span class="line">　　所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。</span><br><span class="line">　　换句话说，就是由调用者主动等待这个调用的结果。</span><br><span class="line">　　而异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。</span><br><span class="line">　　换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。</span><br><span class="line">　　举个通俗的例子：</span><br><span class="line">　　你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下&quot;，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。</span><br><span class="line">　　而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。</span><br><span class="line">三、阻塞I&#x2F;O、非阻塞I&#x2F;O</span><br><span class="line">　　阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态。</span><br><span class="line">　　阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。</span><br><span class="line">　　非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</span><br><span class="line">　　举个通俗的例子：</span><br><span class="line"> 　 你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果。</span><br><span class="line">　　如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。</span><br><span class="line">　　在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;https-通讯流程&quot;&gt;&lt;a href=&quot;#https-通讯流程&quot; class=&quot;headerlink&quot; title=&quot;https 通讯流程&quot;&gt;&lt;/a&gt;https 通讯流程&lt;/h4&gt;&lt;figure class=&quot;highlight properties&quot;&gt;&lt;tab</summary>
      
    
    
    
    <category term="ops" scheme="http://yoursite.com/categories/ops/"/>
    
    
    <category term="杂谈" scheme="http://yoursite.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>杂谈</title>
    <link href="http://yoursite.com/2020/08/04/%E6%8A%80%E6%9C%AF%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2020/08/04/%E6%8A%80%E6%9C%AF%E6%A6%82%E5%BF%B5/</id>
    <published>2020-08-04T01:20:50.000Z</published>
    <updated>2020-08-04T01:20:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="技术杂谈"><a href="#技术杂谈" class="headerlink" title="技术杂谈"></a>技术杂谈</h2><h4 id="1-sata-和-sas的区别"><a href="#1-sata-和-sas的区别" class="headerlink" title="1.sata 和 sas的区别"></a>1.sata 和 sas的区别</h4><p>一.性能区别   </p><p>&#8195;&#8195;SAS更好：相比SATA，SAS在磁盘性能5261上更占优势。主要4102得益于强大SCSI指令集(包括SCSI指令队列)、双核处1653理器，以及对硬件顺序流处理的支持。SAS硬盘支持双向全双工模式，为同时发生的读写操作提供了两路活动通道,SATA只能提供单通道和半双工模式，无疑弱了不少。<br>二.sas接口跟sata接口一样吗<br>   不一样，sas的电源和数据口是一体的，可以插sata盘，sata的是分开的，不能插sas盘，sas向下兼容sata设备。</p><h4 id="2-NAS"><a href="#2-NAS" class="headerlink" title="2.NAS"></a>2.NAS</h4><p>&#8195;&#8195;NAS（Network Attached Storage：网络附属存储）按字面简单说就是连接在网络上，具备资料存储功能的装置，因此也称为“网络存储器”。它是一种专用数据存储服务器。它以数据为中心，将存储设备与服务器彻底分离，集中管理数据，从而释放带宽、提高性能、降低总拥有成本、保护投资。其成本远远低于使用服务器存储，而效率却远远高于后者。目前国际著名的NAS企业有Netapp、EMC、OUO等。</p><a id="more"></a><h4 id="3-saas-paas-iaas"><a href="#3-saas-paas-iaas" class="headerlink" title="3.saas paas iaas"></a>3.saas paas iaas</h4><p><img src="https://raw.githubusercontent.com/hzq82/img/master/img/iaas-paas-saas-comparison-1024x759.jpg"></p><p>&#8195;&#8195;通常有三种云服务模型：SaaS（软件即服务），PaaS（平台即服务）和IaaS（基础架构即服务）。 每个都有自己的好处和差异。为了您的组织能作出最佳选择，您有必要了解SaaS，PaaS和IaaS之间的差异。</p><p>SaaS：软件即服务</p><p>软件即服务（也称为云应用程序服务）代表了云市场中企业最常用的选项。 SaaS利用互联网向其用户提供应用程序，这些应用程序由第三方供应商管理。 大多数SaaS应用程序直接通过Web浏览器运行，不需要在客户端进行任何下载或安装。</p><p>PaaS：平台即服务</p><p>云平台服务或平台即服务（PaaS）为某些软件提供云组件，这些组件主要用于应用程序。 PaaS为开发人员提供了一个框架，使他们可以基于它创建自定义应用程序。所有服务器，存储和网络都可以由企业或第三方提供商进行管理，而开发人员可以负责应用程序的管理。</p><p>IaaS：基础架构即服务</p><p>云基础架构服务称为基础架构即服务（IaaS），由高度可扩展和自动化的计算资源组成。 IaaS是完全自助服务，用于访问和监控计算、网络，存储和其他服务等内容，它允许企业按需求和需要购买资源，而不必购买全部硬件。</p><p>参考文档:<a href="https://blog.csdn.net/liujg79/article/details/84453736">https://blog.csdn.net/liujg79/article/details/84453736</a></p><h4 id="GRUB"><a href="#GRUB" class="headerlink" title="GRUB"></a>GRUB</h4><p>&#8195;&#8195;GNU GRUB 是一个多重<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>启动管理器。用来引导不同系统，如<a href="https://baike.baidu.com/item/windows/165458">windows</a>，<a href="https://baike.baidu.com/item/linux/27050">linux</a>。</p><p>GNU GRUB（GRand Unified Bootloader简称“GRUB”）是一个来自<a href="https://baike.baidu.com/item/GNU">GNU</a>项目的多<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192">操作系统</a>启动程序。GRUB是多启动规范的实现，它允许用户可以在<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338">计算机</a>内同时拥有多个<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192">操作系统</a>，并在计算机启动时选择希望运行的操作系统。GRUB可用于选择<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192">操作系统</a>分区上的不同<a href="https://baike.baidu.com/item/%E5%86%85%E6%A0%B8/108410">内核</a>，也可用于向这些<a href="https://baike.baidu.com/item/%E5%86%85%E6%A0%B8/108410">内核</a>传递启动参数。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;技术杂谈&quot;&gt;&lt;a href=&quot;#技术杂谈&quot; class=&quot;headerlink&quot; title=&quot;技术杂谈&quot;&gt;&lt;/a&gt;技术杂谈&lt;/h2&gt;&lt;h4 id=&quot;1-sata-和-sas的区别&quot;&gt;&lt;a href=&quot;#1-sata-和-sas的区别&quot; class=&quot;headerlink&quot; title=&quot;1.sata 和 sas的区别&quot;&gt;&lt;/a&gt;1.sata 和 sas的区别&lt;/h4&gt;&lt;p&gt;一.性能区别   &lt;/p&gt;
&lt;p&gt;&amp;#8195;&amp;#8195;SAS更好：相比SATA，SAS在磁盘性能5261上更占优势。主要4102得益于强大SCSI指令集(包括SCSI指令队列)、双核处1653理器，以及对硬件顺序流处理的支持。SAS硬盘支持双向全双工模式，为同时发生的读写操作提供了两路活动通道,SATA只能提供单通道和半双工模式，无疑弱了不少。&lt;br&gt;二.sas接口跟sata接口一样吗&lt;br&gt;   不一样，sas的电源和数据口是一体的，可以插sata盘，sata的是分开的，不能插sas盘，sas向下兼容sata设备。&lt;/p&gt;
&lt;h4 id=&quot;2-NAS&quot;&gt;&lt;a href=&quot;#2-NAS&quot; class=&quot;headerlink&quot; title=&quot;2.NAS&quot;&gt;&lt;/a&gt;2.NAS&lt;/h4&gt;&lt;p&gt;&amp;#8195;&amp;#8195;NAS（Network Attached Storage：网络附属存储）按字面简单说就是连接在网络上，具备资料存储功能的装置，因此也称为“网络存储器”。它是一种专用数据存储服务器。它以数据为中心，将存储设备与服务器彻底分离，集中管理数据，从而释放带宽、提高性能、降低总拥有成本、保护投资。其成本远远低于使用服务器存储，而效率却远远高于后者。目前国际著名的NAS企业有Netapp、EMC、OUO等。&lt;/p&gt;</summary>
    
    
    
    <category term="IT" scheme="http://yoursite.com/categories/IT/"/>
    
    
    <category term="杂谈" scheme="http://yoursite.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>nps内网穿透</title>
    <link href="http://yoursite.com/2020/08/03/nps%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <id>http://yoursite.com/2020/08/03/nps%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</id>
    <published>2020-08-03T03:08:50.000Z</published>
    <updated>2020-08-03T03:08:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="openwrt之nps内网穿透"><a href="#openwrt之nps内网穿透" class="headerlink" title="openwrt之nps内网穿透"></a>openwrt之nps内网穿透</h2><h4 id="1-需求"><a href="#1-需求" class="headerlink" title="1.需求"></a>1.需求</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">折腾完openwrt后，为了能在公司访问到家中的openwrt管理界面</span></span><br></pre></td></tr></table></figure><h4 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2.准备工作"></a>2.准备工作</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1.一个域名</span></span><br><span class="line"><span class="attr">2.一个有公网ip的服务器服务器（能内网映射公网的也可以），运行服务端nps程序</span></span><br><span class="line"><span class="attr">3.要访问的ip（此处为openwrt的内网ip：192.168.3.252），运行nps客户端程序</span></span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="3-服务端程序下载安装"><a href="#3-服务端程序下载安装" class="headerlink" title="3.服务端程序下载安装"></a>3.服务端程序下载安装</h4><p>GitHub：<a href="https://github.com/cnlh/nps">https://github.com/cnlh/nps</a><br>releases github: <a href="https://github.com/ehang-io/nps/releases">https://github.com/ehang-io/nps/releases</a>  #下载地址</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">我使用的是centos，所以下载对应的版本，客户端openwrt自带，所以不需要下载</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/hzq82/img/master/img/github_nps.jpg"></p><h4 id="4-服务端安装"><a href="#4-服务端安装" class="headerlink" title="4.服务端安装"></a>4.服务端安装</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">wget</span> <span class="string">https://github.com/cnlh/nps/releases/download/v0.26.3/linux_amd64_server.tar.gz</span></span><br><span class="line"><span class="attr">tar</span> <span class="string">xzvf linux_amd64_server.tar.gz</span></span><br><span class="line"><span class="attr">cd</span> <span class="string">~/nps</span></span><br><span class="line"><span class="meta">./nps</span> <span class="string">install</span></span><br><span class="line"><span class="attr">nohup</span> <span class="string">./nps &amp;</span></span><br><span class="line"><span class="comment">#有特殊需求可以修改conf文件，比如端口等，此处没有修改任何配置，默认服务端口8080，访问：</span></span><br><span class="line"><span class="meta">用户名：admin</span> <span class="string">密码：123（默认）</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/hzq82/img/master/img/github_nps1.jpg"></p><h4 id="5-客户端配置"><a href="#5-客户端配置" class="headerlink" title="5.客户端配置"></a>5.客户端配置</h4><p><img src="https://raw.githubusercontent.com/hzq82/img/master/img/github_nps2.jpg"></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#端口默认8024是客户端访问服务端的端口，秘钥为自己定义，服务端需要配置此秘钥</span></span><br></pre></td></tr></table></figure><h4 id="6-服务端配置"><a href="#6-服务端配置" class="headerlink" title="6. 服务端配置"></a>6. 服务端配置</h4><p><img src="https://raw.githubusercontent.com/hzq82/img/master/img/github_nps3.jpg"></p><p><img src="https://raw.githubusercontent.com/hzq82/img/master/img/github_nps4.jpg"></p><p><img src="https://raw.githubusercontent.com/hzq82/img/master/img/github_nps5.jpg"></p><p>至此所有都配置完成，下图访问效果</p><p><img src="https://raw.githubusercontent.com/hzq82/img/master/img/github_nps6.jpg"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;openwrt之nps内网穿透&quot;&gt;&lt;a href=&quot;#openwrt之nps内网穿透&quot; class=&quot;headerlink&quot; title=&quot;openwrt之nps内网穿透&quot;&gt;&lt;/a&gt;openwrt之nps内网穿透&lt;/h2&gt;&lt;h4 id=&quot;1-需求&quot;&gt;&lt;a href=&quot;#1-需求&quot; class=&quot;headerlink&quot; title=&quot;1.需求&quot;&gt;&lt;/a&gt;1.需求&lt;/h4&gt;&lt;figure class=&quot;highlight properties&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;折腾完openwrt后，为了能在公司访问到家中的openwrt管理界面&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;2-准备工作&quot;&gt;&lt;a href=&quot;#2-准备工作&quot; class=&quot;headerlink&quot; title=&quot;2.准备工作&quot;&gt;&lt;/a&gt;2.准备工作&lt;/h4&gt;&lt;figure class=&quot;highlight properties&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;1.一个域名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;2.一个有公网ip的服务器服务器（能内网映射公网的也可以），运行服务端nps程序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;3.要访问的ip（此处为openwrt的内网ip：192.168.3.252），运行nps客户端程序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="ops" scheme="http://yoursite.com/categories/ops/"/>
    
    
    <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>nginx</title>
    <link href="http://yoursite.com/2020/07/24/nginx/"/>
    <id>http://yoursite.com/2020/07/24/nginx/</id>
    <published>2020-07-24T07:30:50.000Z</published>
    <updated>2020-07-24T07:30:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><p><strong>一、介绍</strong></p><p>​    Nginx是一个高性能的<strong>HTTP**</strong>和反向代理服务器<strong>，也是一个</strong>IMAP/POP3/SMTP**<strong>代理服务器</strong>。</p><p>​     Nginx是一款轻量级的Web服务器/反向代理服务器以及电子邮件代理服务器，并在一个BSD-like协议下发行。由俄罗斯的程序设计师lgor Sysoev所开发，供俄国大型的入口网站及搜索引擎Rambler使用。其特点是<strong>占有内存少，并发能力强</strong>，事实上nginx的并发能力确实在同类型的网页服务器中表现较好。</p><p>​     Nginx相较于Apache\lighttpd具有占有内存少，稳定性高等优势，并且依靠并发能力强，丰富的模块库以及友好灵活的配置而闻名。<strong>在**</strong>Linux**<strong>操作系统下</strong>，nginx使用<strong>epoll事件模型</strong>,得益于此，nginx在Linux操作系统下效率相当高。同时Nginx在OpenBSD或FreeBSD操作系统上采用类似于Epoll的高效事件模型kqueue.</p><a id="more"></a><p><strong>二、名词解释</strong></p><p><strong>代理服务器</strong></p><p>一般是指局域网内部的机器<strong>通过代理服务器</strong>发送请求到互联网上的服务器，代理服务器一般作用在客户端。</p><p><strong>反向代理</strong></p><p>​      客户端（用户A）向反向代理的<strong>命名空间（**</strong>name-space**<strong>）中的内容</strong>发送普通请求，接着反向代理将判断<strong>向何处（原始服务器）转交请求</strong>，并将获得的内容返回给客户端。而客户端始终认为它访问的是原始服务器B而不是服务器Z。由于防火墙作用，只允许服务器Z进出，防火墙和反向代理共同作用保护了院子资源服务器B。</p><p><img src="https://img-blog.csdn.net/20150630214513300?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1dGVuZ3RlbmcxMzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>​     <strong>用途：将防火墙后面的服务器提供给Internet用户访问。反向代理还可以为后端的多台服务器提供负载平衡或为后端较慢的服务器提供缓冲服务。</strong></p><p><strong>正向代理</strong></p><p>​     正向代理是一个位于<strong>客户端**</strong>A和原始服务器（服务器B）之间的服务器（代理服务器Z**），为了从原始服务器取得内容，用户A向代理服务器Z发送一个请求并指定目标（服务器B），然后代理服务器Z向服务器B转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。</p><p><img src="https://img-blog.csdn.net/20150630214532017?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1dGVuZ3RlbmcxMzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>​      用途：<strong>在防火墙内的局域网客户端提供访问**</strong>Internet**<strong>的途径</strong>。还可以使用缓冲特性减少网络使用率。</p><p>从安全性来讲：</p><p>​    <strong>正向代理允许客户端通过它访问任意网站并且隐藏客户端自身</strong>，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务。</p><p>​    反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。</p><p><strong>三、Nginx VSApache</strong></p><p>相同点：</p><p>1、都是HTTP服务器软件</p><p>2、功能上都采用模块化结构设计</p><p>3、都支持通用的语言接口，如PHP、Perl、Python等</p><p>4、支持正向、反向代理、虚拟主机、URL重写、压缩传输、SSL加密传输</p><p>不同点：</p><p>1、Apache处理速度很慢，占用很多内存资源</p><p>2、功能上，Apache所有模块支持动静态编译，<strong>Nginx模块都是静态编译的</strong></p><p>3、对Fcgi的支持：Apache支持的很不好，Nginx支持非常好</p><p>4、处理连接方式：<strong>Nginx支持epoll,Apache不支持</strong></p><p>5、空间使用上：<strong>Nginx安装包仅几百K</strong></p><p>四、Nginx优势</p><p>1、作为Web服务器，<strong>Nginx处理静态文件、索引文件，自动索引的效率非常高</strong></p><p>2、作为代理服务器，Nginx可以实现无缓存的反向代理加速，提高网站运行速度</p><p>3、作为负载均衡服务器，Nginx既可以在内部直接支持Rails和PHP，也可以支持HTTP代理服务器对外进行服务，同时还<strong>支持简单的容错和利用算法进行负载均衡</strong></p><p>4、在性能方面，Nginx是专门为性能优化而开发的，实现上非常注重效率。它采用内核Poll模型，可以支持更多的并发连接，最大可以支持对5万个并发连接数的响应，而且只占用很低的内存资源</p><p>5、在稳定性方面，Nginx采取了<strong>分阶段资源分配技术</strong>，使得CPU与内存的占用率非常低。Nginx官方表示，Nginx保持1万个没有活动的连接，而这些连接只占用2.5MB内存，因此，类似DOS这样的攻击对Nginx来说基本上是没有任何作用的</p><p>6、在高可用性方面，<strong>Nginx支持热部署，启动速度特别迅速，因此可以在不间断服务的情况下，对软件版本或者配置进行升级，即使运行数月也无需重新启动，几乎可以做到7x24小时不间断地运行</strong></p><p>   Nginx具有很高的稳定性；支持热部署；代码质量非常高，代码很规范，手法成熟，模块扩展也很容易；采用了一些os提供的最新特性如对sendfile(Linux2.2+),accept-filter（FreeBSD4.1+）,TCP_DEFER_ACCEPT(Linux 2.4+)的支持，从而大大提高了性能。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;nginx&quot;&gt;&lt;a href=&quot;#nginx&quot; class=&quot;headerlink&quot; title=&quot;nginx&quot;&gt;&lt;/a&gt;nginx&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;一、介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​    Nginx是一个高性能的&lt;strong&gt;HTTP**&lt;/strong&gt;和反向代理服务器&lt;strong&gt;，也是一个&lt;/strong&gt;IMAP/POP3/SMTP**&lt;strong&gt;代理服务器&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;​     Nginx是一款轻量级的Web服务器/反向代理服务器以及电子邮件代理服务器，并在一个BSD-like协议下发行。由俄罗斯的程序设计师lgor Sysoev所开发，供俄国大型的入口网站及搜索引擎Rambler使用。其特点是&lt;strong&gt;占有内存少，并发能力强&lt;/strong&gt;，事实上nginx的并发能力确实在同类型的网页服务器中表现较好。&lt;/p&gt;
&lt;p&gt;​     Nginx相较于Apache\lighttpd具有占有内存少，稳定性高等优势，并且依靠并发能力强，丰富的模块库以及友好灵活的配置而闻名。&lt;strong&gt;在**&lt;/strong&gt;Linux**&lt;strong&gt;操作系统下&lt;/strong&gt;，nginx使用&lt;strong&gt;epoll事件模型&lt;/strong&gt;,得益于此，nginx在Linux操作系统下效率相当高。同时Nginx在OpenBSD或FreeBSD操作系统上采用类似于Epoll的高效事件模型kqueue.&lt;/p&gt;</summary>
    
    
    
    <category term="ops" scheme="http://yoursite.com/categories/ops/"/>
    
    
    <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>linux</title>
    <link href="http://yoursite.com/2020/07/24/linux/"/>
    <id>http://yoursite.com/2020/07/24/linux/</id>
    <published>2020-07-24T07:30:50.000Z</published>
    <updated>2020-07-24T07:30:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><p>1、什么是运维？运维的分类？</p><p>1）运维是指大型组织已经建立好的网络软硬件的维护，就是要保证业务的上线与运作的正常，在他运转的过程中，对他进行维护，他集合了网络、系统、数据库、开发、安全、监控于一身的技术，运维又包括很多种，有DBA运维、网站运维、虚拟化运维、监控运维、游戏运维等等</p><a id="more"></a><p>2）运维又有分工，分为开发运维、应用运维（业务运维）和系统运维</p><p>开发运维：是给应用运维开发运维工具和运维平台的<br>应用运维：是给业务上线、维护和做故障排除的，用开发运维开发出来的工具给业务上线、维护、做故障排查<br>系统运维：是给应用运维提供业务上的基础设施，比如：系统、网络、监控、硬件等等</p><p>总结：开发运维和系统运维给应用运维提供了“工具”和“基础设施”上的支撑</p><p>开发运维、应用运维和系统运维他们的工作是环环相扣的</p><p>2、在工作中，运维人员经常需要跟运营人员打交道，请问运营人员是做什么工作的？</p><p>游戏运营要做的一个事情除了协调工作以外，还需要与各平台沟通，做好开服的时间、开服数、用户导量、活动等计划</p><p>3、现在给你三百台服务器，你怎么对他们进行管理？</p><p>管理3百台服务器的方式：<br>1）设定跳板机，使用统一账号登录，便于安全与登录的考量。<br>2）使用salt、ansiable、puppet进行系统的统一调度与配置的统一管理。<br>3）建立简单的服务器的系统、配置、应用的cmdb信息管理。便于查阅每台服务器上的各种信息记录。</p><p>4、简述raid0 raid1 raid5 三种工作模式的工作原理及特点</p><p>RAID，可以把硬盘整合成一个大磁盘，还可以在大磁盘上再分区，放数据<br>还有一个大功能，多块盘放在一起可以有冗余（备份）<br>RAID整合方式有很多，常用的：0 1 5 10</p><p>RAID 0，可以是一块盘和N个盘组合</p><p>其优点读写快，是RAID中最好的<br>缺点：没有冗余，一块坏了数据就全没有了</p><p>RAID 1，只能2块盘，盘的大小可以不一样，以小的为准</p><p>10G+10G只有10G，另一个做备份。它有100%的冗余，缺点：浪费资源，成本高</p><p>RAID 5 ，3块盘，容量计算10*（n-1）,损失一块盘</p><p>特点，读写性能一般，读还好一点，写不好</p><p>冗余从好到坏：RAID1 RAID10 RAID 5 RAID0</p><p>性能从好到坏：RAID0 RAID10 RAID5 RAID1</p><p>成本从低到高：RAID0 RAID5 RAID1 RAID10</p><p>单台服务器：很重要盘不多，系统盘，RAID1</p><p>数据库服务器：主库：RAID10 从库 RAID5RAID0（为了维护成本，RAID10）</p><p>WEB服务器，如果没有太多的数据的话，RAID5,RAID0（单盘）</p><p>有多台，监控、应用服务器，RAID0 RAID5</p><p>我们会根据数据的存储和访问的需求，去匹配对应的RAID级别</p><p>5、LVS、Nginx、HAproxy有什么区别？工作中你怎么选择？</p><p>LVS：是基于四层的转发<br>HAproxy：是基于四层和七层的转发，是专业的代理服务器<br>Nginx：是WEB服务器，缓存服务器，又是反向代理服务器，可以做七层的转发</p><p><strong>区别</strong>：LVS由于是基于四层的转发所以只能做端口的转发，而基于URL的、基于目录的这种转发LVS就做不了</p><p><strong>工作选择</strong>：</p><p>HAproxy和Nginx由于可以做七层的转发，所以URL和目录的转发都可以做，在很大并发量的时候我们就要选择LVS，像中小型公司的话并发量没那么大，选择HAproxy或者Nginx足已，由于HAproxy由是专业的代理服务器，配置简单，所以中小型企业推荐使用HAproxy</p><p>6、Squid、Varinsh和Nginx有什么区别，工作中你怎么选择？</p><p>Squid、Varinsh和Nginx都是代理服务器</p><p>什么是代理服务器：</p><p>能当替用户去访问公网，并且能把访问到的数据缓存到服务器本地，等用户下次再访问相同的资源的时候，代理服务器直接从本地回应给用户，当本地没有的时候，我代替你去访问公网，我接收你的请求，我先在我自已的本地缓存找，如果我本地缓存有，我直接从我本地的缓存里回复你，如果我在我本地没有找到你要访问的缓存的数据，那么代理服务器就会代替你去访问公网</p><p><strong>区别：</strong></p><p>1）Nginx本来是反向代理/web服务器，用了插件可以做做这个副业但是本身不支持特性挺多，只能缓存静态文件</p><p>2）从这些功能上。varnish和squid是专业的cache服务，而nginx这些是第三方模块完成</p><p>3）varnish本身的技术上优势要高于squid，它采用了可视化页面缓存技术</p><p>在内存的利用上，Varnish比Squid具有优势，性能要比Squid高。</p><p>还有强大的通过Varnish管理端口，可以使用正则表达式快速、批量地清除部分缓存</p><p>它是内存缓存，速度一流，但是内存缓存也限制了其容量，缓存页面和图片一般是挺好的</p><p>4）squid的优势在于完整的庞大的cache技术资料，和很多的应用生产环境</p><p>工作中选择：</p><p>要做cache服务的话，我们肯定是要选择专业的cache服务，优先选择squid或者varnish。</p><p>7、Tomcat和Resin有什么区别，工作中你怎么选择？</p><p>区别：Tomcat用户数多，可参考文档多，Resin用户数少，可考虑文档少<br>最主要区别则是Tomcat是标准的java容器，不过性能方面比resin的要差一些<br>但稳定性和java程序的兼容性，应该是比resin的要好</p><p>工作中选择：现在大公司都是用resin，追求性能；而中小型公司都是用Tomcat，追求稳定和程序的兼容</p><p>8、什么是中间件？什么是jdk？</p><p>中间件介绍：</p><p>中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源</p><p>中间件位于客户机/ 服务器的操作系统之上，管理计算机资源和网络通讯<br>是连接两个独立应用程序或独立系统的软件。相连接的系统，即使它们具有不同的接口</p><p>但通过中间件相互之间仍能交换信息。执行中间件的一个关键途径是信息传递，通过中间件，应用程序可以工作于多平台或OS环境。</p><p>jdk：jdk是Java的开发工具包，它是一种用于构建在 Java 平台上发布的应用程序、applet 和组件的开发环境</p><p>9、讲述一下Tomcat8005、8009、8080三个端口的含义？</p><p>8005==》 关闭时使用</p><p>8009==》 为AJP端口，即容器使用，如Apache能通过AJP协议访问Tomcat的8009端口</p><p>8080==》 一般应用使用</p><p>10、什么叫CDN？</p><ul><li>即内容分发网络</li><li>其目的是通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络边缘，使用户可就近取得所需的内容，提高用户访问网站的速度</li></ul><p>11、什么叫网站灰度发布？</p><p>灰度发布是指在黑与白之间，能够平滑过渡的一种发布方式</p><p>AB test就是一种灰度发布方式，让一部用户继续用A，一部分用户开始用B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度</p><p>12、简述DNS进行域名解析的过程？</p><p>用户要访问<a href="http://www.baidu.com,会先找本机的host文件,再找本地设置的dns服务器,如果也没有的话,就去网络中找根服务器,根服务器反馈结果,说只能提供一级域名服务器.cn,就去找一级域名服务器,一级域名服务器说只能提供二级域名服务器.com.cn,就去找二级域名服务器,二级域服务器只能提供三级域名服务器.baidu.com.cn,就去找三级域名服务器,三级域名服务器正好有这个网站www.baidu.com,然后发给请求的服务器,保存一份之后,再发给客户端/">www.baidu.com，会先找本机的host文件，再找本地设置的DNS服务器，如果也没有的话，就去网络中找根服务器，根服务器反馈结果，说只能提供一级域名服务器.cn，就去找一级域名服务器，一级域名服务器说只能提供二级域名服务器.com.cn,就去找二级域名服务器，二级域服务器只能提供三级域名服务器.baidu.com.cn，就去找三级域名服务器，三级域名服务器正好有这个网站www.baidu.com，然后发给请求的服务器，保存一份之后，再发给客户端</a></p><p>13、RabbitMQ是什么东西？</p><p>RabbitMQ也就是消息队列中间件，消息中间件是在消息的传息过程中保存消息的容器<br>消息中间件再将消息从它的源中到它的目标中标时充当中间人的作用<br>队列的主要目的是提供路由并保证消息的传递；如果发送消息时接收者不可用<br>消息队列不会保留消息，直到可以成功地传递为止，当然，消息队列保存消息也是有期限地</p><p>14、讲一下Keepalived的工作原理？</p><p>在一个虚拟路由器中，只有作为MASTER的VRRP路由器会一直发送VRRP通告信息,<br>BACKUP不会抢占MASTER，除非它的优先级更高。当MASTER不可用时(BACKUP收不到通告信息)<br>多台BACKUP中优先级最高的这台会被抢占为MASTER。这种抢占是非常快速的(&lt;1s)，以保证服务的连续性<br>由于安全性考虑，VRRP包使用了加密协议进行加密。BACKUP不会发送通告信息，只会接收通告信息</p><p>15、讲述一下LVS三种模式的工作过程？</p><p>LVS 有三种负载均衡的模式，分别是VS/NAT（nat 模式） VS/DR(路由模式) VS/TUN（隧道模式）</p><p><strong>一、NAT模式（VS-NAT）</strong></p><p><strong>原理</strong>：就是把客户端发来的数据包的IP头的目的地址，在负载均衡器上换成其中一台RS的IP地址<br>并发至此RS来处理,RS处理完后把数据交给负载均衡器,负载均衡器再把数据包原IP地址改为自己的IP<br>将目的地址改为客户端IP地址即可期间,无论是进来的流量,还是出去的流量,都必须经过负载均衡器<br><strong>优点</strong>：集群中的物理服务器可以使用任何支持TCP/IP操作系统，只有负载均衡器需要一个合法的IP地址<br><strong>缺点</strong>：扩展性有限。当服务器节点（普通PC服务器）增长过多时,负载均衡器将成为整个系统的瓶颈<br>因为所有的请求包和应答包的流向都经过负载均衡器。当服务器节点过多时<br>大量的数据包都交汇在负载均衡器那，速度就会变慢！</p><p><strong>二、IP隧道模式（VS-TUN）</strong></p><p><strong>原理</strong>：首先要知道，互联网上的大多Internet服务的请求包很短小，而应答包通常很大<br>那么隧道模式就是，把客户端发来的数据包，封装一个新的IP头标记(仅目的IP)发给RS<br>RS收到后,先把数据包的头解开,还原数据包,处理后,直接返回给客户端,不需要再经过<br>负载均衡器。注意,由于RS需要对负载均衡器发过来的数据包进行还原,所以说必须支持<br>IPTUNNEL协议，所以,在RS的内核中,必须编译支持IPTUNNEL这个选项<br><strong>优点</strong>：负载均衡器只负责将请求包分发给后端节点服务器，而RS将应答包直接发给用户<br>所以，减少了负载均衡器的大量数据流动，负载均衡器不再是系统的瓶颈，就能处理很巨大的请求量<br>这种方式，一台负载均衡器能够为很多RS进行分发。而且跑在公网上就能进行不同地域的分发。<br><strong>缺点</strong>：隧道模式的RS节点需要合法IP，这种方式需要所有的服务器支持”IP Tunneling”<br>(IP Encapsulation)协议，服务器可能只局限在部分Linux系统上</p><p>**三、直接路由模式（VS-DR）<br>**</p><p><strong>原理</strong>：负载均衡器和RS都使用同一个IP对外服务但只有DR对ARP请求进行响应<br>所有RS对本身这个IP的ARP请求保持静默也就是说,网关会把对这个服务IP的请求全部定向给DR<br>而DR收到数据包后根据调度算法,找出对应的RS,把目的MAC地址改为RS的MAC（因为IP一致）<br>并将请求分发给这台RS这时RS收到这个数据包,处理完成之后，由于IP一致，可以直接将数据返给客户<br>则等于直接从客户端收到这个数据包无异,处理后直接返回给客户端<br>由于负载均衡器要对二层包头进行改换,所以负载均衡器和RS之间必须在一个广播域<br>也可以简单的理解为在同一台交换机上<br><strong>优点</strong>：和TUN（隧道模式）一样，负载均衡器也只是分发请求，应答包通过单独的路由方法返回给客户端<br>与VS-TUN相比，VS-DR这种实现方式不需要隧道结构，因此可以使用大多数操作系统做为物理服务器。<br><strong>缺点</strong>：（不能说缺点，只能说是不足）要求负载均衡器的网卡必须与物理网卡在一个物理段上。</p><p>16、mysql的innodb如何定位锁问题，mysql如何减少主从复制延迟？</p><p>mysql的innodb如何定位锁问题:<br>在使用 show engine innodb status检查引擎状态时，发现了死锁问题<br>在5.5中，information_schema 库中增加了三个关于锁的表（MEMORY引擎）<br>innodb_trx     ## 当前运行的所有事务<br>innodb_locks   ## 当前出现的锁<br>innodb_lock_waits  ## 锁等待的对应关系</p><p>mysql如何减少主从复制延迟:</p><p>如果延迟比较大，就先确认以下几个因素：</p><ol><li>从库硬件比主库差，导致复制延迟</li><li>主从复制单线程，如果主库写并发太大，来不及传送到从库就会导致延迟。</li><li>更高版本的mysql可以支持多线程复制</li><li>慢SQL语句过多</li><li>网络延迟</li><li>master负载，主库读写压力大，导致复制延迟，架构的前端要加buffer及缓存层</li><li>slave负载，一般的做法是，使用多台slave来分摊读请求，再从这些slave中取一台专用的服务器，只作为备份用，不进行其他任何操作.另外， 2个可以减少延迟的参数:–slave-net-timeout=seconds 单位为秒 默认设置为 3600秒</li></ol><blockquote><p>参数含义：当slave从主数据库读取log数据失败后，等待多久重新建立连接并获取数据</p></blockquote><p>–master-connect-retry=seconds 单位为秒 默认设置为 60秒</p><blockquote><p>参数含义：当重新建立主从连接时，如果连接建立失败，间隔多久后重试</p></blockquote><p>通常配置以上2个参数可以减少网络问题导致的主从数据同步延迟</p><p><strong>MySQL数据库主从同步延迟解决方案</strong></p><p>最简单的减少slave同步延时的方案就是在架构上做优化，尽量让主库的DDL快速执行，还有就是主库是写，对数据安全性较高，比如sync_binlog=1，innodb_flush_log_at_trx_commit= 1 之类的设置，而slave则不需要这么高的数据安全，完全可以讲sync_binlog设置为0或者关闭binlog，innodb_flushlog也可以设置为0来提高sql的执行效率。另外就是使用比主库更好的硬件设备作为slave</p><p>17、如何重置mysql root密码？</p><p>一、 在已知MYSQL数据库的ROOT用户密码的情况下，修改密码的方法：</p><p>1、 在SHELL环境下，使用mysqladmin命令设置：<br>   mysqladmin –u root –p password “新密码”  回车后要求输入旧密码</p><p>2、 在mysql&gt;环境中,使用update命令，直接更新mysql库user表的数据：</p><p>   Update  mysql.user  set  password=password(‘新密码’)  where  user=’root’;<br>   flush  privileges;<br>   注意：mysql语句要以分号”；”结束</p><p>3、 在mysql&gt;环境中，使用grant命令，修改root用户的授权权限。</p><p>   grant  all  on  <em>.</em> to  root@’localhost’  identified  by  ‘新密码’；</p><p>二、 如查忘记了mysql数据库的ROOT用户的密码，又如何做呢？方法如下：</p><p>1、 关闭当前运行的mysqld服务程序：service  mysqld  stop（要先将mysqld添加为系统服务）<br>2、 使用mysqld_safe脚本以安全模式（不加载授权表）启动mysqld 服务<br>   /usr/local/mysql/bin/mysqld_safe  –skip-grant-table  &amp;<br>3、 使用空密码的root用户登录数据库，重新设置ROOT用户的密码<br>   ＃mysql  -u  root<br>   Mysql&gt; Update  mysql.user  set  password=password(‘新密码’)  where  user=’root’;<br>   Mysql&gt; flush  privileges;</p><p>18、lvs/nginx/haproxy优缺点</p><p>Nginx的优点是：<br>1、工作在网络的7层之上，可以针对http应用做一些分流的策略，比如针对域名、目录结构，它的正则规则比HAProxy更为强大和灵活，这也是它目前广泛流行的主要原因之一，Nginx单凭这点可利用的场合就远多于LVS了。</p><p>2、Nginx对网络稳定性的依赖非常小，理论上能ping通就就能进行负载功能，这个也是它的优势之一，相反LVS对网络稳定性依赖比较大，这点本人深有体会；</p><p>3、Nginx安装和配置比较简单，测试起来比较方便，它基本能把错误用日志打印出来，LVS的配置、测试就要花比较长的时间了，LVS对网络依赖比较大。</p><p>4、可以承担高负载压力且稳定，在硬件不差的情况下一般能支撑几万次的并发量，负载度比LVS相对小些。</p><p>5、Nginx可以通过端口检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点，不过其中缺点就是不支持url来检测。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而不满。</p><p>6、Nginx不仅仅是一款优秀的负载均衡器/反向代理软件，它同时也是功能强大的Web应用服务器，LNMP也是近几年非常流行的web架构，在高流量的环境中稳定性也很好。</p><p>7、Nginx现在作为Web反向加速缓存越来越成熟了，速度比传统的Squid服务器更快，可考虑用其作为反向代理加速器</p><p>8、Nginx可作为中层反向代理使用，这一层面Nginx基本上无对手，唯一可以对比Nginx的就只有lighttpd了，不过lighttpd目前还没有做到Nginx完全的功能，配置也不那么清晰易读，社区资料也远远没Nginx活跃</p><p>9、Nginx也可作为静态网页和图片服务器，这方面的性能也无对手。还有Nginx社区非常活跃，第三方模块也很多</p><p><strong>Nginx的缺点是：</strong></p><p>1、Nginx仅能支持http、https和Email协议，这样就在适用范围上面小些，这个是它的缺点<br>2、对后端服务器的健康检查，只支持通过端口来检测，不支持通过url来检测<br>   不支持Session的直接保持，但能通过ip_hash来解决</p><p>LVS：使用Linux内核集群实现一个高性能、高可用的负载均衡服务器，它具有很好的可伸缩性（Scalability)、可靠性（Reliability)和可管理性（Manageability)</p><p><strong>LVS的优点是</strong>：</p><p>1、抗负载能力强、是工作在网络4层之上仅作分发之用，没有流量的产生，这个特点也决定了它在负载均衡软件里的性能最强的，对内存和cpu资源消耗比较低</p><p>2、配置性比较低，这是一个缺点也是一个优点，因为没有可太多配置的东西，所以并不需要太多接触，大大减少了人为出错的几率</p><p>3、工作稳定，因为其本身抗负载能力很强，自身有完整的双机热备方案，如LVS+Keepalived，不过我们在项目实施中用得最多的还是LVS/DR+Keepalived</p><p>4、无流量，LVS只分发请求，而流量并不从它本身出去，这点保证了均衡器IO的性能不会收到大流量的影响。</p><p>5、应用范围较广，因为LVS工作在4层，所以它几乎可对所有应用做负载均衡，包括http、数据库、在线聊天室等</p><p><strong>LVS的缺点是：</strong></p><p>1、软件本身不支持正则表达式处理，不能做动静分离<br>   而现在许多网站在这方面都有较强的需求，这个是Nginx/HAProxy+Keepalived的优势所在<br>2、如果是网站应用比较庞大的话，LVS/DR+Keepalived实施起来就比较复杂了，特别后面有Windows Server的机器的话，如果实施及配置还有维护过程就比较复杂了，相对而言，Nginx/HAProxy+Keepalived就简单多了。</p><p><strong>HAProxy的特点是：</strong></p><p>1、HAProxy也是支持虚拟主机的。</p><p>2、HAProxy的优点能够补充Nginx的一些缺点，比如支持Session的保持，Cookie的引导，同时支持通过获取指定的url来检测后端服务器的状态</p><p>3、HAProxy跟LVS类似，本身就只是一款负载均衡软件，单纯从效率上来讲HAProxy会比Nginx有更出色的负载均衡速度，在并发处理上也是优于Nginx的</p><p>4、HAProxy支持TCP协议的负载均衡转发，可以对MySQL读进行负载均衡，对后端的MySQL节点进行检测和负载均衡，大家可以用LVS+Keepalived对MySQL主从做负载均衡</p><p>5、HAProxy负载均衡策略非常多，HAProxy的负载均衡算法现在具体有如下8种：</p><p>①roundrobin，表示简单的轮询，这个不多说，这个是负载均衡基本都具备的；<br>② static-rr，表示根据权重，建议关注；<br>③leastconn，表示最少连接者先处理，建议关注；<br>④ source，表示根据请求源IP，这个跟Nginx的IP_hash机制类似<br>  我们用其作为解决session问题的一种方法，建议关注；<br>⑤ri，表示根据请求的URI；<br>⑥rl_param，表示根据请求的URl参数’balance url_param’ requires an URL parameter name；<br>⑦hdr(name)，表示根据HTTP请求头来锁定每一次HTTP请求；<br>⑧rdp-cookie(name)，表示根据据cookie(name)来锁定并哈希每一次TCP请求。</p><p>19、mysql数据备份工具</p><p>mysqldump工具，mysqldump是mysql自带的备份工具，目录在bin目录下面：/usr/local/mysql/bin/mysqldump，支持基于innodb的热备份，但是由于是逻辑备份，所以速度不是很快，适合备份数据比较小的场景，Mysqldump完全备份+二进制日志可以实现基于时间点的恢复。</p><p><strong>基于LVM快照备份</strong></p><p>在物理备份中，有基于文件系统的物理备份（LVM的快照），也可以直接用tar之类的命令对整个数据库目录<br>进行打包备份，但是这些只能进行泠备份，不同的存储引擎备份的也不一样，myisam自动备份到表级别<br>而innodb不开启独立表空间的话只能备份整个数据库。</p><p><strong>tar包备份</strong></p><p>percona提供的xtrabackup工具，支持innodb的物理热备份，支持完全备份，增量备份，而且速度非常快，支持innodb存储引起的数据在不同，数据库之间迁移，支持复制模式下的从机备份恢复备份恢复，为了让xtrabackup支持更多的功能扩展，可以设立独立表空间，打开 innodb_file_per_table功能，启用之后可以支持单独的表备份</p><p>20、keepalive的工作原理和如何做到健康检查</p><p>keepalived是以VRRP协议为实现基础的，VRRP全称Virtual Router Redundancy Protocol，即虚拟路由冗余协议。</p><p>虚拟路由冗余协议，可以认为是实现路由器高可用的协议，即将N台提供相同功能的路由器组成一个路由器组<br>这个组里面有一个master和多个backup，master上面有一个对外提供服务的vip（该路由器所在局域网内<br>其他机器的默认路由为该vip），master会发组播，当backup收不到vrrp包时就认为master宕掉了<br>这时就需要根据VRRP的优先级来选举一个backup当master。这样就可以保证路由器的高可用了</p><p>keepalived主要有三个模块，分别是core、check和vrrp。core模块为keepalived的核心，负责主进程的启动、维护及全局配置文件的加载和解析。check负责健康检查，包括常见的各种检查方式，vrrp模块是来实现VRRP协议的</p><p>Keepalived健康检查方式配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HTTP_GET|SSL_GET</span><br><span class="line">HTTP_GET | SSL_GET</span><br><span class="line">&#123;</span><br><span class="line">url &#123;</span><br><span class="line">path &#x2F;# HTTP&#x2F;SSL 检查的url可以是多个</span><br><span class="line">digest  # HTTP&#x2F;SSL 检查后的摘要信息用工具genhash生成</span><br><span class="line">status_code 200# HTTP&#x2F;SSL 检查返回的状态码</span><br><span class="line">&#125;</span><br><span class="line">connect_port 80 # 连接端口</span><br><span class="line">bindto</span><br><span class="line">connect_timeout 3 # 连接超时时间</span><br><span class="line">nb_get_retry 3 # 重连次数</span><br><span class="line">delay_before_retry 2 #连接间隔时间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>21、统计ip访问情况，要求分析nginx访问日志，找出访问页面数量在前十位的ip</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log | awk ‘&#123;print $1&#125;’ | uniq -c | sort -rn | head -10</span><br></pre></td></tr></table></figure><p>22、使用tcpdump监听主机为192.168.1.1，tcp端口为80的数据，同时将输出结果保存输出到tcpdump.log</p></li><li></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump ‘host 192.168.1.1 and port 80’ &gt; tcpdump.log</span><br></pre></td></tr></table></figure><p>23、如何将本地80 端口的请求转发到8080 端口，当前主机IP 为192.168.2.1</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A PREROUTING -d 192.168.2.1 -p tcp -m tcp -dport 80 -j DNAT-to-destination 192.168.2.1:8080</span><br></pre></td></tr></table></figure><p>24、简述raid0 raid1 raid5 三种工作模式的工作原理及特点</p></li></ul><p><strong>RAID 0</strong>：带区卷，连续以位或字节为单位分割数据，并行读/写于多个磁盘上，因此具有很高的数据传输率<br>但它没有数据冗余，RAID 0 只是单纯地提高性能，并没有为数据的可靠性提供保证<br>而且其中的一个磁盘失效将影响到所有数据。因此，RAID 0 不能应用于数据安全性要求高的场合</p><p><strong>RAID 1：</strong>镜像卷，它是通过磁盘数据镜像实现数据冗余，在成对的独立磁盘上产生互为备份的数据</p><p>不能提升写数据效率。当原始数据繁忙时，可直接从镜像拷贝中读取数据，因此RAID1 可以提高读取性能<br>RAID 1 是磁盘阵列中单位成本最高的，镜像卷可用容量为总容量的1/2，但提供了很高的数据安全性和可用性<br>当一个磁盘失效时，系统可以自动切换到镜像磁盘上读写，而不需要重组失效的数据</p><p><strong>RAID5：</strong>至少由3块硬盘组成，分布式奇偶校验的独立磁盘结构，它的奇偶校验码存在于所有磁盘上</p><p>任何一个硬盘损坏，都可以根据其它硬盘上的校验位来重建损坏的数据（最多允许1块硬盘损坏）<br>所以raid5可以实现数据冗余，确保数据的安全性，同时raid5也可以提升数据的读写性能</p><p>25、你对现在运维工程师的理解和以及对其工作的认识</p><p>运维工程师在公司当中责任重大，需要保证时刻为公司及客户提供最高、最快、最稳定、最安全的服务<br>运维工程师的一个小小的失误，很有可能会对公司及客户造成重大损失<br>因此运维工程师的工作需要严谨及富有创新精神</p><p>26、实时抓取并显示当前系统中tcp 80端口的网络数据信息，请写出完整操作命令</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -nn tcp port 80</span><br></pre></td></tr></table></figure><p>27、服务器开不了机怎么解决一步步的排查</p></li></ul><p>A、造成服务器故障的原因可能有以下几点：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/QFzRdz9libEawR0xuaPapN1QiaC4vL4Hr4b7fQichUYZFr4kxH9E1MxvjBKTNQJhMJSudcpFx6Q4H3oBdpUV6WIkw/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>B、如何排查服务器故障的处理步骤如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/QFzRdz9libEawR0xuaPapN1QiaC4vL4Hr4qibFylR5Fic1c64uvxzlkWMJ0SzcWsTvQmrL2NaRCbuqGwpKzos3WA0w/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>28、Linux系统中病毒怎么解决<br>1）最简单有效的方法就是重装系统<br>2）要查的话就是找到病毒文件然后删除<br>中毒之后一般机器cpu、内存使用率会比较高，机器向外发包等异常情况，排查方法简单介绍下，top 命令找到cpu使用率最高的进程，一般病毒文件命名都比较乱，可以用 ps aux 找到病毒文件位置，rm -f  命令删除病毒文件，检查计划任务、开机启动项和病毒文件目录有无其他可以文件等</p><p>3）由于即使删除病毒文件不排除有潜伏病毒，所以最好是把机器备份数据之后重装一下</p><p>29、发现一个病毒文件你删了他又自动创建怎么解决</p><p>公司的内网某台linux服务器流量莫名其妙的剧增,用iftop查看有连接外网的情况<br>针对这种情况一般重点查看netstat连接的外网ip和端口。用lsof -p pid可以查看到具体是那些进程，哪些文件，经查勘发现/root下有相关的配置conf.n hhe两个可疑文件，rm -rf后不到一分钟就自动生成了，由此推断是某个母进程产生的这些文件。所以找到母进程就是找到罪魁祸首</p><p>查杀病毒最好断掉外网访问，还好是内网服务器，可以通过内网访问</p><p>断了内网，病毒就失去外联的能力，杀掉它就容易的多，怎么找到呢，找了半天也没有看到蛛丝马迹，没办法只有ps axu一个个排查，方法是查看可以的用户和和系统相似而又不是的冒牌货，果然，看到了如下进程可疑，看不到图片就是/usr/bin/.sshd，于是我杀掉所有.sshd相关的进程，然后直接删掉.sshd这个可执行文件，然后才删掉了文章开头提到的自动复活的文件</p><p>总结一下，遇到这种问题，如果不是太严重，尽量不要重装系统</p><p>一般就是先断外网，然后利用iftop,ps,netstat,chattr,lsof,pstree这些工具顺藤摸瓜<br>一般都能找到元凶。但是如果遇到诸如此类的问题<br>/boot/efi/EFI/redhat/grub.efi: Heuristics.Broken.Executable FOUND，个人觉得就要重装系统了</p><p>30、说说TCP/IP的七层模型</p><p>应用层 (Application)：<br>网络服务与最终用户的一个接口。<br>协议有：HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP</p><p>表示层（Presentation Layer）：</p><p>数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层）<br>格式有，JPEG、ASCll、DECOIC、加密格式等</p><p>会话层（Session Layer）：</p><p>建立、管理、终止会话。（在五层模型里面已经合并到了应用层）<br>对应主机进程，指本地主机与远程主机正在进行的会话</p><p>传输层 (Transport)：</p><p>定义传输数据的协议端口号，以及流控和差错校验。<br>协议有：TCP UDP，数据包一旦离开网卡即进入网络传输层</p><p>网络层 (Network)：</p><p>进行逻辑地址寻址，实现不同网络之间的路径选择。<br>协议有：ICMP IGMP IP（IPV4 IPV6） ARP RARP</p><p>数据链路层 (Link)：</p><p>建立逻辑连接、进行硬件地址寻址、差错校验等功能。（由底层网络定义协议）<br>将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正</p><p>物理层（Physical Layer）：</p><p>是计算机网络OSI模型中最低的一层</p><p>物理层规定:为传输数据所需要的物理链路创建、维持、拆除<br>而提供具有机械的，电子的，功能的和规范的特性</p><p>简单的说，物理层确保原始的数据可在各种物理媒体上传输。局域网与广域网皆属第1、2层</p><p>物理层是OSI的第一层，它虽然处于最底层，却是整个开放系统的基础<br>物理层为设备之间的数据通信提供传输媒体及互连设备，为数据传输提供可靠的环境<br>如果您想要用尽量少的词来记住这个第一层，那就是“信号和介质”</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;linux&quot;&gt;&lt;a href=&quot;#linux&quot; class=&quot;headerlink&quot; title=&quot;linux&quot;&gt;&lt;/a&gt;linux&lt;/h2&gt;&lt;p&gt;1、什么是运维？运维的分类？&lt;/p&gt;
&lt;p&gt;1）运维是指大型组织已经建立好的网络软硬件的维护，就是要保证业务的上线与运作的正常，在他运转的过程中，对他进行维护，他集合了网络、系统、数据库、开发、安全、监控于一身的技术，运维又包括很多种，有DBA运维、网站运维、虚拟化运维、监控运维、游戏运维等等&lt;/p&gt;</summary>
    
    
    
    <category term="ops" scheme="http://yoursite.com/categories/ops/"/>
    
    
    <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
</feed>
